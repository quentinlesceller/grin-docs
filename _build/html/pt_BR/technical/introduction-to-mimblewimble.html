

<!DOCTYPE html>
<html class="writer-html5" lang="pt-BR" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Technical Introduction to Mimblewimble &mdash; documentação Grin v4.0.0</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/custom.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Índice" href="../genindex.html" />
    <link rel="search" title="Buscar" href="../search.html" />
    <link rel="next" title="Grin for Bitcoiners" href="grin-for-bitcoiners.html" />
    <link rel="prev" title="Table of Contents" href="table-of-contents.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home" alt="Documentation Home"> Grin
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
    
            
            
              
            
            
              <p class="caption"><span class="caption-text">Integration</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../integration/index.html">Integration</a></li>
</ul>
<p class="caption"><span class="caption-text">Technical Details</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="table-of-contents.html">Table of Contents</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Technical Introduction to Mimblewimble</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#tongue-tying-for-everyone">Tongue Tying for Everyone</a></li>
<li class="toctree-l2"><a class="reference internal" href="#tiny-bits-of-elliptic-curves">Tiny Bits of Elliptic Curves</a></li>
<li class="toctree-l2"><a class="reference internal" href="#transacting-with-mimblewimble">Transacting with Mimblewimble</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#balance">Balance</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ownership">Ownership</a></li>
<li class="toctree-l3"><a class="reference internal" href="#some-finer-points">Some Finer Points</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#change">Change</a></li>
<li class="toctree-l4"><a class="reference internal" href="#range-proofs">Range Proofs</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#putting-it-all-together">Putting It All Together</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#blocks-and-chain-state">Blocks and Chain State</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#transaction-aggregation">Transaction Aggregation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#kernel-offsets">Kernel Offsets</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#cut-through">Cut-through</a></li>
<li class="toctree-l3"><a class="reference internal" href="#cut-through-all-the-way">Cut-through All The Way</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#conclusion">Conclusion</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="grin-for-bitcoiners.html">Grin for Bitcoiners</a></li>
<li class="toctree-l1"><a class="reference internal" href="building-blocks/index.html">Building Blocks</a></li>
<li class="toctree-l1"><a class="reference internal" href="blockchain-and-consensus/index.html">Blockchain and Consensus</a></li>
<li class="toctree-l1"><a class="reference internal" href="miscellaneous/index.html">Miscellaneous</a></li>
</ul>

            
          
    <a href="genindex.html">Keyword Index</a>
  
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Grin</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Technical Introduction to Mimblewimble</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/technical/introduction-to-mimblewimble.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="technical-introduction-to-mimblewimble">
<h1>Technical Introduction to Mimblewimble<a class="headerlink" href="#technical-introduction-to-mimblewimble" title="Link permanente para este título">¶</a></h1>
<div class="section" id="tongue-tying-for-everyone">
<h2>Tongue Tying for Everyone<a class="headerlink" href="#tongue-tying-for-everyone" title="Link permanente para este título">¶</a></h2>
<p>This document is targeted at readers with a good understanding of
blockchains and basic cryptography. With that in mind, we attempt to
explain the technical buildup of Mimblewimble and how it’s applied in
Grin. We hope this document is understandable to most technically-minded
readers. Our objective is to encourage you to get interested in Grin and
contribute in any way possible.</p>
<p>To achieve this objective, we will introduce the main concepts required
for a good understanding of Grin as a Mimblewimble implementation. We
will start with a brief description of some relevant properties of
Elliptic Curve Cryptography (ECC) to lay the foundation on which Grin is
based and then describe all the key elements of a Mimblewimble
blockchain’s transactions and blocks.</p>
</div>
<div class="section" id="tiny-bits-of-elliptic-curves">
<h2>Tiny Bits of Elliptic Curves<a class="headerlink" href="#tiny-bits-of-elliptic-curves" title="Link permanente para este título">¶</a></h2>
<p>We start with a brief primer on Elliptic Curve Cryptography, reviewing
just the properties necessary to understand how Mimblewimble works and
without delving too much into the intricacies of ECC. For readers who
would want to dive deeper into those assumptions, there are other
opportunities to <a class="reference external" href="http://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/">learn
more</a>.</p>
<p>An Elliptic Curve for the purpose of cryptography is simply a large set
of points that we will call <em>C</em>. These points can be added, subtracted,
or multiplied by integers (also called scalars). Given such a point <em>H</em>,
an integer <em>k</em> and using the scalar multiplication operation we can
compute <code class="docutils literal notranslate"><span class="pre">k*H</span></code>, which is also a point on curve <em>C</em>. Given another
integer <em>j</em> we can also calculate <code class="docutils literal notranslate"><span class="pre">(k+j)*H</span></code>, which equals
<code class="docutils literal notranslate"><span class="pre">k*H</span> <span class="pre">+</span> <span class="pre">j*H</span></code>. The addition and scalar multiplication operations on an
elliptic curve maintain the commutative and associative properties of
addition and multiplication:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="n">j</span><span class="p">)</span><span class="o">*</span><span class="n">H</span> <span class="o">=</span> <span class="n">k</span><span class="o">*</span><span class="n">H</span> <span class="o">+</span> <span class="n">j</span><span class="o">*</span><span class="n">H</span>
</pre></div>
</div>
<p>In ECC, if we pick a very large number <em>k</em> as a private key, <code class="docutils literal notranslate"><span class="pre">k*H</span></code> is
considered the corresponding public key. Even if one knows the value of
the public key <code class="docutils literal notranslate"><span class="pre">k*H</span></code>, deducing <em>k</em> is close to impossible (or said
differently, while multiplication is trivial, “division” by curve points
is extremely difficult).</p>
<p>The previous formula <code class="docutils literal notranslate"><span class="pre">(k+j)*H</span> <span class="pre">=</span> <span class="pre">k*H</span> <span class="pre">+</span> <span class="pre">j*H</span></code>, with <em>k</em> and <em>j</em> both
private keys, demonstrates that a public key obtained from the addition
of two private keys (<code class="docutils literal notranslate"><span class="pre">(k+j)*H</span></code>) is identical to the addition of the
public keys for each of those two private keys (<code class="docutils literal notranslate"><span class="pre">k*H</span> <span class="pre">+</span> <span class="pre">j*H</span></code>). In the
Bitcoin blockchain, Hierarchical Deterministic wallets heavily rely on
this principle. Mimblewimble and the Grin implementation do as well.</p>
</div>
<div class="section" id="transacting-with-mimblewimble">
<h2>Transacting with Mimblewimble<a class="headerlink" href="#transacting-with-mimblewimble" title="Link permanente para este título">¶</a></h2>
<p>The structure of transactions demonstrates a crucial tenet of
Mimblewimble: strong privacy and confidentiality guarantees.</p>
<p>The validation of Mimblewimble transactions relies on two basic
properties:</p>
<ul class="simple">
<li><p><strong>Verification of zero sums.</strong> The sum of outputs minus inputs always
equals zero, proving that the transaction did not create new funds,
<em>without revealing the actual amounts</em>.</p></li>
<li><p><strong>Possession of private keys.</strong> Like with most other
cryptocurrencies, ownership of transaction outputs is guaranteed by
the possession of ECC private keys. However, the proof that an entity
owns those private keys is not achieved by directly signing the
transaction.</p></li>
</ul>
<p>The next sections on balance, ownership, change and proofs details how
those two fundamental properties are achieved.</p>
<div class="section" id="balance">
<h3>Balance<a class="headerlink" href="#balance" title="Link permanente para este título">¶</a></h3>
<p>Building upon the properties of ECC we described above, one can obscure
the values in a transaction.</p>
<p>If <em>v</em> is the value of a transaction input or output and <em>H</em> a point on
the elliptic curve <em>C</em>, we can simply embed <code class="docutils literal notranslate"><span class="pre">v*H</span></code> instead of <em>v</em> in a
transaction. This works because using the ECC operations, we can still
validate that the sum of the outputs of a transaction equals the sum of
inputs:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">v1</span> <span class="o">+</span> <span class="n">v2</span> <span class="o">=</span> <span class="n">v3</span>  <span class="o">=&gt;</span>  <span class="n">v1</span><span class="o">*</span><span class="n">H</span> <span class="o">+</span> <span class="n">v2</span><span class="o">*</span><span class="n">H</span> <span class="o">=</span> <span class="n">v3</span><span class="o">*</span><span class="n">H</span>
</pre></div>
</div>
<p>Verifying this property on every transaction allows the protocol to
verify that a transaction doesn’t create money out of thin air, without
knowing what the actual values are. However, there are a finite number
of usable values (transaction amounts) and one could try every single
one of them to guess the value of the transaction. In addition, knowing
<em>v1</em> (from a previous transaction for example) and the resulting
<code class="docutils literal notranslate"><span class="pre">v1*H</span></code> reveals all outputs with value <em>v1</em> across the blockchain. For
these reasons, we introduce a second point <em>G</em> on the same elliptic
curve (practically <em>G</em> is just another generator point on the same curve
group as <em>H</em>) and a private key <em>r</em> used as a <em>blinding factor</em>.</p>
<p>An input or output value in a transaction can then be expressed as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">r</span><span class="o">*</span><span class="n">G</span> <span class="o">+</span> <span class="n">v</span><span class="o">*</span><span class="n">H</span>
</pre></div>
</div>
<p>Where:</p>
<ul class="simple">
<li><p><em>r</em> is a private key used as a blinding factor, <em>G</em> is a point on the
elliptic curve <em>C</em> and their product <code class="docutils literal notranslate"><span class="pre">r*G</span></code> is the public key for
<em>r</em> (using <em>G</em> as generator point).</p></li>
<li><p><em>v</em> is the value of an input or output and <em>H</em> is another point on
the elliptic curve <em>C</em>, together producing another public key <code class="docutils literal notranslate"><span class="pre">v*H</span></code>
(using <em>H</em> as generator point).</p></li>
</ul>
<p>Neither <em>v</em> nor <em>r</em> can be deduced, leveraging the fundamental
properties of Elliptic Curve Cryptography. <code class="docutils literal notranslate"><span class="pre">r*G</span> <span class="pre">+</span> <span class="pre">v*H</span></code> is called a
<em>Pedersen Commitment</em>.</p>
<p>As an example, let’s assume we want to build a transaction with two
inputs and one output. We have (ignoring fees):</p>
<ul class="simple">
<li><p><em>vi1</em> and <em>vi2</em> as input values.</p></li>
<li><p><em>vo3</em> as output value.</p></li>
</ul>
<p>Such that:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">vi1</span> <span class="o">+</span> <span class="n">vi2</span> <span class="o">=</span> <span class="n">vo3</span>
</pre></div>
</div>
<p>Generating a private key as a blinding factor for each input value and
replacing each value with their respective Pedersen Commitments in the
previous equation, we obtain:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">ri1</span><span class="o">*</span><span class="n">G</span> <span class="o">+</span> <span class="n">vi1</span><span class="o">*</span><span class="n">H</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">ri2</span><span class="o">*</span><span class="n">G</span> <span class="o">+</span> <span class="n">vi2</span><span class="o">*</span><span class="n">H</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">ro3</span><span class="o">*</span><span class="n">G</span> <span class="o">+</span> <span class="n">vo3</span><span class="o">*</span><span class="n">H</span><span class="p">)</span>
</pre></div>
</div>
<p>Which as a consequence requires that:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ri1</span> <span class="o">+</span> <span class="n">ri2</span> <span class="o">=</span> <span class="n">ro3</span>
</pre></div>
</div>
<p>This is the first pillar of Mimblewimble: the arithmetic required to
validate a transaction can be done without knowing any of the values.</p>
<p>As a final note, this idea is actually derived from Greg Maxwell’s
<a class="reference external" href="https://elementsproject.org/features/confidential-transactions/investigation">Confidential
Transactions</a>,
which is itself derived from an <a class="reference external" href="https://bitcointalk.org/index.php?topic=305791.0">Adam Back proposal for homomorphic
values</a> applied to
Bitcoin.</p>
</div>
<div class="section" id="ownership">
<h3>Ownership<a class="headerlink" href="#ownership" title="Link permanente para este título">¶</a></h3>
<p>In the previous section we introduced a private key as a blinding factor
to obscure the transaction’s values. The second insight of Mimblewimble
is that this private key can be leveraged to prove ownership of the
value.</p>
<p>Alice sends you 3 coins and to obscure that amount, you chose 28 as your
blinding factor (note that in practice, the blinding factor being a
private key, it’s an extremely large number). Somewhere on the
blockchain, the following output appears and should only be spendable by
you:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="mi">28</span><span class="o">*</span><span class="n">G</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">H</span>
</pre></div>
</div>
<p><em>X</em>, the result of the addition, is visible by everyone. The value 3 is
only known to you and Alice, and 28 is only known to you.</p>
<p>To transfer those 3 coins again, the protocol requires 28 to be known
somehow. To demonstrate how this works, let’s say you want to transfer
those 3 same coins to Carol. You need to build a simple transaction such
that:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Xi</span> <span class="o">=&gt;</span> <span class="n">Y</span>
</pre></div>
</div>
<p>Where <em>Xi</em> is an input that spends your <em>X</em> output and <em>Y</em> is Carol’s
output. There is no way to build such a transaction and balance it
without knowing your private key of 28. Indeed, if Carol is to balance
this transaction, she needs to know both the value sent and your private
key so that:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Y</span> <span class="o">-</span> <span class="n">Xi</span> <span class="o">=</span> <span class="p">(</span><span class="mi">28</span><span class="o">*</span><span class="n">G</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">H</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="mi">28</span><span class="o">*</span><span class="n">G</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">H</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="o">*</span><span class="n">G</span> <span class="o">+</span> <span class="mi">0</span><span class="o">*</span><span class="n">H</span>
</pre></div>
</div>
<p>By checking that everything has been zeroed out, we can again make sure
that no new money has been created.</p>
<p>Wait! Stop! Now you know the private key in Carol’s output (which, in
this case, must be the same as yours to balance out) and so you could
steal the money back from Carol!</p>
<p>To solve this, Carol uses a private key of her choosing. She picks 113
say, and what ends up on the blockchain is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Y</span> <span class="o">-</span> <span class="n">Xi</span> <span class="o">=</span> <span class="p">(</span><span class="mi">113</span><span class="o">*</span><span class="n">G</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">H</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="mi">28</span><span class="o">*</span><span class="n">G</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">H</span><span class="p">)</span> <span class="o">=</span> <span class="mi">85</span><span class="o">*</span><span class="n">G</span> <span class="o">+</span> <span class="mi">0</span><span class="o">*</span><span class="n">H</span>
</pre></div>
</div>
<p>Now the transaction no longer sums to zero and we have an <em>excess value</em>
(85), which is the result of the summation of all blinding factors.
Because <code class="docutils literal notranslate"><span class="pre">85*G</span></code> is a valid public key for the generator point <em>G</em> the
input and output values must sum to zero and the transaction is thus
valid, since <code class="docutils literal notranslate"><span class="pre">x*G</span> <span class="pre">+</span> <span class="pre">y*H</span></code> is a valid public key for generator point <em>G</em>
if and only if <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">0</span></code>.</p>
<p>So all the protocol needs to verify is that (<code class="docutils literal notranslate"><span class="pre">Y</span> <span class="pre">-</span> <span class="pre">Xi</span></code>) is a valid
public key for generator point <em>G</em> and that the transacting parties
collectively can produce its private key (85 in the above example). The
simplest way to do so is to require a signature built with the excess
value (85), which then ensures that:</p>
<ul class="simple">
<li><p>The transacting parties collectively can produce the private key (the
excess value)</p></li>
<li><p>The sum of the outputs minus the inputs are zero (because only a
valid public key will check against the signature).</p></li>
</ul>
<p>This signature, attached to every transaction, together with some
additional data (like mining fees), is called a <em>transaction kernel</em> and
is checked by all validators.</p>
</div>
<div class="section" id="some-finer-points">
<h3>Some Finer Points<a class="headerlink" href="#some-finer-points" title="Link permanente para este título">¶</a></h3>
<p>This section elaborates on the building of transactions by discussing
how change is introduced and the requirement for range proofs so all
values are proven to be non-negative. Neither of these are absolutely
required to understand Mimblewimble and Grin, so if you’re in a hurry,
feel free to jump straight to <a class="reference external" href="#putting-it-all-together">Putting It All
Together</a>.</p>
<div class="section" id="change">
<h4>Change<a class="headerlink" href="#change" title="Link permanente para este título">¶</a></h4>
<p>Let’s say you only want to send 2 coins to Carol from the 3 you received
from Alice. To do this you would send the remaining 1 coin back to
yourself as change. You generate another private key (say 12) as a
blinding factor to protect your change output. Carol uses her own
private key as before.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Change</span> <span class="n">output</span><span class="p">:</span>     <span class="mi">12</span><span class="o">*</span><span class="n">G</span> <span class="o">+</span> <span class="mi">1</span><span class="o">*</span><span class="n">H</span>
<span class="n">Carol</span><span class="s1">&#39;s output:    113*G + 2*H</span>
</pre></div>
</div>
<p>What ends up on the blockchain is something very similar to before. And
the signature is again built with the excess value, 97 in this example.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="mi">12</span><span class="o">*</span><span class="n">G</span> <span class="o">+</span> <span class="mi">1</span><span class="o">*</span><span class="n">H</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">113</span><span class="o">*</span><span class="n">G</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">H</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="mi">28</span><span class="o">*</span><span class="n">G</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">H</span><span class="p">)</span> <span class="o">=</span> <span class="mi">97</span><span class="o">*</span><span class="n">G</span> <span class="o">+</span> <span class="mi">0</span><span class="o">*</span><span class="n">H</span>
</pre></div>
</div>
</div>
<div class="section" id="range-proofs">
<h4>Range Proofs<a class="headerlink" href="#range-proofs" title="Link permanente para este título">¶</a></h4>
<p>In all the above calculations, we rely on the transaction values to
always be positive. The introduction of negative amounts would be
extremely problematic as one could create new funds in every
transaction.</p>
<p>For example, one could create a transaction with an input of 2 and
outputs of 5 and -3 and still obtain a well-balanced transaction. This
can’t be easily detected because even if <em>x</em> is negative, the
corresponding point <code class="docutils literal notranslate"><span class="pre">x*H</span></code> on the curve looks like any other.</p>
<p>To solve this problem, Mimblewimble leverages another cryptographic
concept (also coming from Confidential Transactions) called range
proofs: a proof that a number falls within a given range, without
revealing the number. We won’t elaborate on the range proof, but you
just need to know that for any <code class="docutils literal notranslate"><span class="pre">r*G</span> <span class="pre">+</span> <span class="pre">v*H</span></code> we can build a proof that
will show that <em>v</em> is greater than zero and does not overflow.</p>
<p>It’s also important to note that range proofs for both the blinding
factor and the values are needed. The reason for this is that it
prevents a censoring attack where a third party would be able to lock
UTXOs without knowing their private keys by creating a transaction such
as the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Carol</span><span class="s1">&#39;s UTXO:      113*G + 2*H</span>
<span class="n">Attacker</span><span class="s1">&#39;s output: (113 + 99)*G + 2*H</span>
</pre></div>
</div>
<p>which can be signed by the attacker because Carol’s blinding factor
cancels out in the equation <code class="docutils literal notranslate"><span class="pre">Y</span> <span class="pre">-</span> <span class="pre">Xi</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Y</span> <span class="o">-</span> <span class="n">Xi</span> <span class="o">=</span> <span class="p">((</span><span class="mi">113</span> <span class="o">+</span> <span class="mi">99</span><span class="p">)</span><span class="o">*</span><span class="n">G</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">H</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="mi">113</span><span class="o">*</span><span class="n">G</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">H</span><span class="p">)</span> <span class="o">=</span>  <span class="mi">99</span><span class="o">*</span><span class="n">G</span>
</pre></div>
</div>
<p>This output (<code class="docutils literal notranslate"><span class="pre">(113</span> <span class="pre">+</span> <span class="pre">99)*G</span> <span class="pre">+</span> <span class="pre">2*H</span></code>) requires that both the numbers 113
and 99 are known in order to be spent; the attacker would thus have
successfully locked Carol’s UTXO. The requirement for a range proof for
the blinding factor prevents this because the attacker doesn’t know the
number 113 and thus neither (113 + 99). A more detailed description of
range proofs is further detailed in the <a class="reference external" href="https://eprint.iacr.org/2017/1066.pdf">range proof
paper</a>.</p>
</div>
</div>
<div class="section" id="putting-it-all-together">
<h3>Putting It All Together<a class="headerlink" href="#putting-it-all-together" title="Link permanente para este título">¶</a></h3>
<p>A Mimblewimble transaction includes the following:</p>
<ul class="simple">
<li><p>A set of inputs, that reference and spend a set of previous outputs.</p></li>
<li><p>A set of new outputs that include:</p>
<ul>
<li><p>A value and a blinding factor (which is just a new private key)
multiplied on a curve and summed to be <code class="docutils literal notranslate"><span class="pre">r*G</span> <span class="pre">+</span> <span class="pre">v*H</span></code>.</p></li>
<li><p>A range proof that among other things shows that <em>v</em> is
non-negative.</p></li>
</ul>
</li>
<li><p>An transaction fee in cleartext.</p></li>
<li><p>A signature whose private key is computed by taking the excess value
(the sum of all output values plus the fee, minus the input values).</p></li>
</ul>
</div>
</div>
<div class="section" id="blocks-and-chain-state">
<h2>Blocks and Chain State<a class="headerlink" href="#blocks-and-chain-state" title="Link permanente para este título">¶</a></h2>
<p>We explained above how Mimblewimble transactions can provide strong
anonymity guarantees while maintaining the properties required for a
valid blockchain, i.e., a transaction does not create money and proof of
ownership is established through private keys.</p>
<p>The Mimblewimble block format builds on this by introducing one
additional concept: <em>cut-through</em>. With this addition, a Mimblewimble
chain gains:</p>
<ul class="simple">
<li><p>Extremely good scalability, as the great majority of transaction data
can be eliminated over time, without compromising security.</p></li>
<li><p>Further anonymity by mixing and removing transaction data.</p></li>
</ul>
<div class="section" id="transaction-aggregation">
<h3>Transaction Aggregation<a class="headerlink" href="#transaction-aggregation" title="Link permanente para este título">¶</a></h3>
<p>Recall that a transaction consists of the following:</p>
<ul class="simple">
<li><p>a set of inputs that reference and spent a set of previous outputs</p></li>
<li><p>a set of new outputs</p></li>
<li><p>a transaction kernel consisting of:</p>
<ul>
<li><p>kernel excess (the public key of the excess value)</p></li>
<li><p>transaction signature whose public key is the kernel excess</p></li>
</ul>
</li>
</ul>
<p>A transaction is validated by determining that the kernel excess is a
valid public key:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="mi">42</span><span class="o">*</span><span class="n">G</span> <span class="o">+</span> <span class="mi">1</span><span class="o">*</span><span class="n">H</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">99</span><span class="o">*</span><span class="n">G</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">H</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="mi">113</span><span class="o">*</span><span class="n">G</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">H</span><span class="p">)</span> <span class="o">=</span> <span class="mi">28</span><span class="o">*</span><span class="n">G</span> <span class="o">+</span> <span class="mi">0</span><span class="o">*</span><span class="n">H</span>
</pre></div>
</div>
<p>The public key in this example is <code class="docutils literal notranslate"><span class="pre">28*G</span></code>.</p>
<p>We can say the following is true for any valid transaction (ignoring
fees for simplicity):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">sum</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span> <span class="o">=</span> <span class="n">kernel_excess</span>
</pre></div>
</div>
<p>The same holds true for blocks themselves once we realize a block is
simply a set of aggregated inputs, outputs and transaction kernels. We
can sum the outputs, subtract the inputs from it and equating the
resulting Pedersen commitment to the sum of the kernel excesses:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">sum</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">kernel_excess</span><span class="p">)</span>
</pre></div>
</div>
<p>Simplifying slightly, (again ignoring transaction fees) we can say that
Mimblewimble blocks can be treated exactly as Mimblewimble transactions.</p>
<div class="section" id="kernel-offsets">
<h4>Kernel Offsets<a class="headerlink" href="#kernel-offsets" title="Link permanente para este título">¶</a></h4>
<p>There is a subtle problem with Mimblewimble blocks and transactions as
described above. It is possible (and in some cases trivial) to
reconstruct the constituent transactions in a block. This is clearly bad
for privacy. This is the “subset” problem: given a set of inputs,
outputs, and transaction kernels a subset of these will recombine to
reconstruct a valid transaction.</p>
<p>Consider the following two transactions:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">out1</span><span class="p">),</span> <span class="p">(</span><span class="n">kern1</span><span class="p">)</span>
<span class="p">(</span><span class="n">in3</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">out2</span><span class="p">),</span> <span class="p">(</span><span class="n">kern2</span><span class="p">)</span>
</pre></div>
</div>
<p>We can aggregate them into the following block (or aggregate
transaction):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">in3</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">out1</span><span class="p">,</span> <span class="n">out2</span><span class="p">),</span> <span class="p">(</span><span class="n">kern1</span><span class="p">,</span> <span class="n">kern2</span><span class="p">)</span>
</pre></div>
</div>
<p>It is trivially easy to try all possible permutations to recover one of
the transactions (where it successfully sums to zero):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">out1</span><span class="p">),</span> <span class="p">(</span><span class="n">kern1</span><span class="p">)</span>
</pre></div>
</div>
<p>We also know that everything remaining can be used to reconstruct the
other valid transaction:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">in3</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">out2</span><span class="p">),</span> <span class="p">(</span><span class="n">kern2</span><span class="p">)</span>
</pre></div>
</div>
<p>Remember that the kernel excess <code class="docutils literal notranslate"><span class="pre">r*G</span></code> simply is the public key of the
excess value <em>r</em>. To mitigate this we redefine the kernel excess from
<code class="docutils literal notranslate"><span class="pre">r*G</span></code> to <code class="docutils literal notranslate"><span class="pre">(r-kernel_offset)*G</span></code> and distribute the <em>kernel offset</em> to
be included with every transaction kernel. The kernel offset is thus a
blinding factor that needs to be added to the excess value to ensure the
commitments sum to zero:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">sum</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span> <span class="o">=</span> <span class="n">r</span><span class="o">*</span><span class="n">G</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span><span class="o">-</span><span class="n">kernel_offset</span><span class="p">)</span><span class="o">*</span><span class="n">G</span> <span class="o">+</span> <span class="n">kernel_offset</span><span class="o">*</span><span class="n">G</span>
</pre></div>
</div>
<p>or alternatively</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">sum</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span> <span class="o">=</span> <span class="n">kernel_excess</span> <span class="o">+</span> <span class="n">kernel_offset</span><span class="o">*</span><span class="n">G</span>
</pre></div>
</div>
<p>For a commitment <code class="docutils literal notranslate"><span class="pre">r*G</span> <span class="pre">+</span> <span class="pre">0*H</span></code> with the offset <code class="docutils literal notranslate"><span class="pre">a</span></code>, the transaction is
signed with <code class="docutils literal notranslate"><span class="pre">(r-a)</span></code> and <em>a</em> is published so that <code class="docutils literal notranslate"><span class="pre">r*G</span></code> can be
calculated in order to verify the validity of the transaction. During
block construction all kernel offsets are summed to generate a <em>single</em>
aggregate kernel offset to cover the whole block. The kernel offset for
any individual transaction is then unrecoverable and the subset problem
is solved.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">sum</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">kernel_excess</span><span class="p">)</span> <span class="o">+</span> <span class="n">kernel_offset</span><span class="o">*</span><span class="n">G</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="cut-through">
<h3>Cut-through<a class="headerlink" href="#cut-through" title="Link permanente para este título">¶</a></h3>
<p>Blocks let miners assemble multiple transactions into a single set
that’s added to the chain. In the following block representations,
containing 3 transactions, we only show inputs and outputs of
transactions. Inputs reference outputs they spend. An output included in
a previous block is marked with a lower-case x.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">I1</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span> <span class="o">---</span> <span class="n">O1</span>
        <span class="o">|-</span> <span class="n">O2</span>

<span class="n">I2</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span> <span class="o">---</span> <span class="n">O3</span>
<span class="n">I3</span><span class="p">(</span><span class="n">O2</span><span class="p">)</span> <span class="o">-|</span>

<span class="n">I4</span><span class="p">(</span><span class="n">O3</span><span class="p">)</span> <span class="o">---</span> <span class="n">O4</span>
        <span class="o">|-</span> <span class="n">O5</span>
</pre></div>
</div>
<p>We notice the two following properties:</p>
<ul class="simple">
<li><p>Within this block, some outputs are directly spent by following
inputs (<em>I3</em> spends <em>O2</em> and <em>I4</em> spends <em>O3</em>).</p></li>
<li><p>The structure of each transaction does not actually matter. Since all
transactions individually sum to zero, the sum of all transaction
inputs and outputs must be zero.</p></li>
</ul>
<p>Similarly to a transaction, all that needs to be checked in a block is
that ownership has been proven (which comes from the <em>transaction
kernels</em>) and that the whole block did not create any coins (other than
what’s allowed as the mining reward). Therefore, matching inputs and
outputs can be eliminated, as their contribution to the overall sum
cancels out. Which leads to the following, much more compact block:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">I1</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span> <span class="o">|</span> <span class="n">O1</span>
<span class="n">I2</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span> <span class="o">|</span> <span class="n">O4</span>
       <span class="o">|</span> <span class="n">O5</span>
</pre></div>
</div>
<p>Note that all transaction structure has been eliminated and the order of
inputs and outputs does not matter anymore. However, the sum of all
inputs and outputs is still guaranteed to be zero.</p>
<p>A block is simply built from:</p>
<ul class="simple">
<li><p>A block header.</p></li>
<li><p>The list of inputs remaining after cut-through.</p></li>
<li><p>The list of outputs remaining after cut-through.</p></li>
<li><p>A single kernel offset to cover the full block.</p></li>
<li><p>The transaction kernels containing, for each transaction:</p>
<ul>
<li><p>The public key <code class="docutils literal notranslate"><span class="pre">r*G</span></code> obtained from the summation of all inputs
and outputs.</p></li>
<li><p>The signatures generated using the excess value.</p></li>
<li><p>The mining fee.</p></li>
</ul>
</li>
</ul>
<p>When structured this way, a Mimblewimble block offers extremely good
privacy guarantees:</p>
<ul class="simple">
<li><p>Intermediate (cut-through) transactions will be represented only by
their transaction kernels.</p></li>
<li><p>All outputs look the same: very large numbers that are impossible to
meaningfully differentiate from one another. If someone wants to
exclude a specific output, they’d have to exclude all.</p></li>
<li><p>All transaction structure has been removed, making it impossible to
tell which inputs and outputs match.</p></li>
</ul>
<p>And yet, it all still validates!</p>
</div>
<div class="section" id="cut-through-all-the-way">
<h3>Cut-through All The Way<a class="headerlink" href="#cut-through-all-the-way" title="Link permanente para este título">¶</a></h3>
<p>Going back to the previous example block, outputs <em>x1</em> and <em>x2</em>, spent
by <em>I1</em> and <em>I2</em>, must have appeared previously in the blockchain. So
after the addition of this block, those outputs as well as <em>I1</em> and <em>I2</em>
can also be removed from the blockchain as they now are intermediate
transactions.</p>
<p>We conclude that the chain state (excluding headers) at any point in
time can be summarized by just these pieces of information:</p>
<ol class="arabic simple">
<li><p>The total amount of coins created by mining in the chain.</p></li>
<li><p>The complete set of unspent outputs.</p></li>
<li><p>The transactions kernels for each transaction.</p></li>
</ol>
<p>The first piece of information can be deduced just using the block
height.</p>
<p>Both the UTXOs and the transaction kernels are extremely compact. This
has two important consequences:</p>
<ul class="simple">
<li><p>The blockchain a node needs to maintain is very small (on the order
of a few gigabytes for a bitcoin-sized blockchain, and potentially
optimizable to a few hundreds of megabytes).</p></li>
<li><p>When a new node joins the network the amount of information that
needs to be transferred is very small.</p></li>
</ul>
<p>In addition, the UTXO set cannot be tampered with. Adding or removing
even one input or output would change the sum of the transactions to be
something other than zero.</p>
</div>
</div>
<div class="section" id="conclusion">
<h2>Conclusion<a class="headerlink" href="#conclusion" title="Link permanente para este título">¶</a></h2>
<p>In this document we covered the basic principles that underlie a
Mimblewimble blockchain. By using the addition properties of Elliptic
Curve Cryptography, we’re able to build transactions that are completely
opaque but can still be properly validated. And by generalizing those
properties to blocks, we can eliminate a large amount of blockchain
data, allowing for great scaling and fast sync of new peers.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="grin-for-bitcoiners.html" class="btn btn-neutral float-right" title="Grin for Bitcoiners" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="table-of-contents.html" class="btn btn-neutral float-left" title="Table of Contents" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, Grin Developers

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  
<div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
    <span class="fa fa-book fa-element"> RTD </span>

    <span class="fa fa-v fa-element"> v:  <span class="fa fa-caret-down"></span></span>

    </span>
    <div class="rst-other-versions">
        <dl>
            <dt>Versions</dt> 
        </dl>
        <dl>
            <dt>Downloads</dt> 
        </dl>
        <dl>
            
            <dt>On Read the Docs</dt>
            <dd>
                <a href="///projects//?fromdocs=">Project Home</a>
            </dd>
            <dd>
                <a href="///builds//?fromdocs=">Builds</a>
            </dd>
        </dl>
    </div>
</div>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>