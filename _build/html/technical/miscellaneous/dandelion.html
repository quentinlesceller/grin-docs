

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Dandelion++ in Grin: Privacy-Preserving Transaction Aggregation and Propagation &mdash; Grin v4.0.0 documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/css/custom.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/css/toggle.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
        <script src="../../_static/js/toggle.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home" alt="Documentation Home"> Grin
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
    
            
            
              
            
            
              <p class="caption"><span class="caption-text">Integration</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../integration/index.html">Integration</a></li>
</ul>
<p class="caption"><span class="caption-text">Technical Details</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../table-of-contents.html">Table of Contents</a></li>
<li class="toctree-l1"><a class="reference internal" href="../introduction-to-mimblewimble.html">Technical Introduction to Mimblewimble</a></li>
<li class="toctree-l1"><a class="reference internal" href="../grin-for-bitcoiners.html">Grin for Bitcoiners</a></li>
</ul>
<p class="caption"><span class="caption-text">Building Blocks</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../building-blocks/merkle-mountain-ranges.html">Merkle Mountain Ranges</a></li>
<li class="toctree-l1"><a class="reference internal" href="../building-blocks/merkle-proof.html">Merkle Proof</a></li>
<li class="toctree-l1"><a class="reference internal" href="../building-blocks/switch-commitments.html">Introduction to Switch Commitments</a></li>
</ul>

            
          
    <a href="genindex.html">Keyword Index</a>
  
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Grin</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Dandelion++ in Grin: Privacy-Preserving Transaction Aggregation and Propagation</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/technical/miscellaneous/dandelion.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="dandelion-in-grin-privacy-preserving-transaction-aggregation-and-propagation">
<h1>Dandelion++ in Grin: Privacy-Preserving Transaction Aggregation and Propagation<a class="headerlink" href="#dandelion-in-grin-privacy-preserving-transaction-aggregation-and-propagation" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>The Dandelion++ protocol for broadcasting transactions, proposed by
Fanti et al. (Sigmetrics 2018)[1], intends to defend against
deanonymization attacks during transaction propagation. In Grin, it also
provides an opportunity to aggregate transactions before they are
broadcasted to the entire network. This document describes the protocol
and the simplified version of it that is implemented in Grin.</p>
<p>In the following section, past research on the protocol is summarized.
This is then followed by describing details of the Grin implementation;
the objectives behind its inclusion, how the current implementation
differs from the original paper, what some of the known limitations are,
and outlining some areas of improvement for future work.</p>
</div>
<div class="section" id="previous-research">
<h2>Previous research<a class="headerlink" href="#previous-research" title="Permalink to this headline">¶</a></h2>
<p>The original version of Dandelion was introduced by Fanti et al. and
presented at ACM Sigmetrics 2017 [2]. On June 2017, a BIP [3] was
proposed introducing a more practical and robust variant of Dandelion
called Dandelion++, which was formalized into a paper in 2018. [1] The
protocols are outlined at a high level here. For a more in-depth
presentation with extensive literature references, please refer to the
original papers.</p>
<div class="section" id="motivation">
<h3>Motivation<a class="headerlink" href="#motivation" title="Permalink to this headline">¶</a></h3>
<p>Dandelion was conceived as a way to mitigate against large scale
deanonymization attacks on the network layer of Bitcoin, made possible
by the diffusion method for propagating transactions on the network. By
deploying “super-nodes” that connect to a large number of honest nodes
on the network, adversaries can listen to the transactions relayed by
the honest nodes as they get diffused symmetrically on the network using
epidemic flooding or diffusion. By observing the spreading dynamic of a
transaction, it has been proven possible to link it (and therefore also
the sender’s Bitcoin address) to the originating IP address with a high
degree of accuracy, and as a result deanonymize users.</p>
</div>
<div class="section" id="original-dandelion">
<h3>Original Dandelion<a class="headerlink" href="#original-dandelion" title="Permalink to this headline">¶</a></h3>
<p>In the original paper [2], a <strong>dandelion spreading protocol</strong> is
introduced. Dandelion spreading propagation consists of two phases:
first the anonymity phase, or the <strong>“stem”</strong> phase, and second the
spreading phase, or the <strong>“fluff”</strong> phase, as illustrated in Figure 1.</p>
<p><strong>Figure 1.</strong> Dandelion phase illustration.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>                                                 ┌-&gt; F ...
                                         ┌-&gt; D --┤
                                         |       └-&gt; G ...
A --[stem]--&gt; B --[stem]--&gt; C --[fluff]--┤
                                         |       ┌-&gt; H ...
                                         └-&gt; E --┤
                                                 └-&gt; I ...
</pre></div>
</div>
<p>In the initial <strong>stem-phase</strong>, each node relays the transaction to a
<em>single randomly selected peer</em>, constructing a line graph. Users then
forward transactions along the <em>same</em> path on the graph. After a random
number of hops along the single stem, the transaction enters the
<strong>fluff-phase</strong>, which behaves like ordinary diffusion. This means that
even when an attacker can identify the originator of the fluff phase, it
becomes more difficult to identify the source of the stem (and thus the
original broadcaster of the transaction). The constructed line graph is
periodically re-generated randomly, at the expiry of each <em>epoch</em>,
limiting an adversary’s possibility to build knowledge of graph. Epochs
are asynchronous, with each individual node keeping its own internal
clock and starting a new epoch once a certain threshold has been
reached.</p>
<p>The ‘dandelion’ name is derived from how the protocol resembles the
spreading of the seeds of a dandelion.</p>
</div>
<div class="section" id="dandelion">
<h3>Dandelion++<a class="headerlink" href="#dandelion" title="Permalink to this headline">¶</a></h3>
<p>In the Dandelion++ paper[1], the authors build on the original concept
further, by defending against stronger adversaries that are allowed to
disobey protocol.</p>
<p>The original paper makes three idealistic assumptions: 1. All nodes obey
protocol; 2. Each node generates exactly one transaction; and 3. All
nodes on the network run Dandelion.</p>
<p>An adversary can violate these rules, and by doing so break some of the
anonymity properties.</p>
<p>The modified Dandelion++ protocol makes small changes to most of the
Dandelion choices, resulting in an exponentially more complex
information space. This in turn makes it harder for an adversary to
deanonymize the network.</p>
<p>The paper describes five types of attacks, and proposes specific updates
to the original Dandelion protocol to mitigate against these, presented
in Table A (here in summarized form).</p>
<p><strong>Table A.</strong> Summary of Dandelion++ changes</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 39%" />
<col style="width: 61%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Attack</p></th>
<th class="head"><p>Solution</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Graph-learning</p></td>
<td><p>4-regular anonymity graph</p></td>
</tr>
<tr class="row-odd"><td><p>Intersection</p></td>
<td><p>Pseudorandom forwarding</p></td>
</tr>
<tr class="row-even"><td><p>Graph-construction</p></td>
<td><p>Non-interactive construction</p></td>
</tr>
<tr class="row-odd"><td><p>Black-hole</p></td>
<td><p>Random stem timers</p></td>
</tr>
<tr class="row-even"><td><p>Partial deployment</p></td>
<td><p>Blind stem selection</p></td>
</tr>
</tbody>
</table>
<div class="section" id="the-dandelion-algorithm">
<h4>The Dandelion++ algorithm<a class="headerlink" href="#the-dandelion-algorithm" title="Permalink to this headline">¶</a></h4>
<p>As with the original Dandelion protocol epochs are asynchronous, each
node keeping track of its own epoch, which the suggested duration being
in the order of 10 minutes.</p>
<div class="section" id="anonymity-graph">
<h5>1. Anonymity Graph<a class="headerlink" href="#anonymity-graph" title="Permalink to this headline">¶</a></h5>
<p>Rather than a line graph as per the original paper (which is 2-regular),
a <em>quasi-4-regular graph</em> (Figure 2) is constructed by a node at the
beginning of each epoch: the node chooses (up to) two of its outbound
edges uniformly at random as its <em>dandelion++ relays</em>. As a node enters
into a new epoch, new dandelion++ relays are chosen.</p>
<p><strong>Figure 2.</strong> A 4-regular graph.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">in1</span>        <span class="n">out1</span>
  \       <span class="o">/</span>
   \     <span class="o">/</span>
    <span class="n">NodeX</span>
   <span class="o">/</span>     \
  <span class="o">/</span>       \
<span class="n">in2</span>        <span class="n">out2</span>
</pre></div>
</div>
<p><em>``NodeX`` has four connections to other nodes, input nodes ``in1`` and
``in2``, and output nodes ``out1`` and ``out2``.</em></p>
<p><strong>Note on using 4-regular vs 2-regular graphs</strong></p>
<p>The choice between using 4-regular or 2-regular (line) graphs is not
obvious. The authors note that it is difficult to construct an exact
4-regular graph within a fully-distributed network in practice. They
outline a method to construct an approximate 4-regular graph in the
paper. They also write:</p>
<blockquote>
<div><p>[…] We recommend making the design decision between 4-regular graphs
and line graphs based on the priorities of the system builders. <strong>If
linkability of transactions is a first-order concern, then line
graphs may be a better choice.</strong> Otherwise, we find that 4-regular
graphs can give constant- order privacy benefits against adversaries
with knowledge of the graph.</p>
</div></blockquote>
</div>
<div class="section" id="transaction-forwarding-own">
<h5>2. Transaction forwarding (own)<a class="headerlink" href="#transaction-forwarding-own" title="Permalink to this headline">¶</a></h5>
<p>At the beginning of each epoch, <code class="docutils literal notranslate"><span class="pre">NodeX</span></code> picks one of <code class="docutils literal notranslate"><span class="pre">out1</span></code> and
<code class="docutils literal notranslate"><span class="pre">out2</span></code> to use as a route to broadcast its own transactions through as
a stem-phase transaction. The <em>same route</em> is used throughout the
duration epoch, and <code class="docutils literal notranslate"><span class="pre">NodeX</span></code> <em>always</em> forwards (stems) its own
transaction.</p>
</div>
<div class="section" id="transaction-forwarding-relay">
<h5>3. Transaction forwarding (relay)<a class="headerlink" href="#transaction-forwarding-relay" title="Permalink to this headline">¶</a></h5>
<p>At the start of each epoch, <code class="docutils literal notranslate"><span class="pre">NodeX</span></code> makes a choice to be either in
fluff-mode or in stem-mode. This choice is made in pseudorandom fashion,
with the paper suggesting it being computed from a hash of the node’s
own identity and epoch number. The probability of choosing to be in
fluff-mode (or as the paper calls it, <em>the path length parameter ``q``</em>)
is recommended to be q ≤ 0.2.</p>
<p>Once the choice has been made whether to stem or to fluff, it applies to
<em>all relayed transactions</em> during the epoch.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">NodeX</span></code> is in <strong>fluff-mode</strong>, it will broadcast any received
transactions to the network using diffusion.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">NodeX</span></code> is in <strong>stem-mode</strong>, then at the beginning of each epoch it
will map <code class="docutils literal notranslate"><span class="pre">in1</span></code> to either <code class="docutils literal notranslate"><span class="pre">out1</span></code> or <code class="docutils literal notranslate"><span class="pre">out2</span></code> pseudorandomly, and
similarly map <code class="docutils literal notranslate"><span class="pre">in2</span></code> to either <code class="docutils literal notranslate"><span class="pre">out1</span></code> or <code class="docutils literal notranslate"><span class="pre">out2</span></code> in the same
fashion. Based on this mapping, it will then forward <em>all</em> txs from
<code class="docutils literal notranslate"><span class="pre">in1</span></code> along the chosen route, and similarly forward all transactions
from <code class="docutils literal notranslate"><span class="pre">in2</span></code> along that route. The mapping persists throughout the
duration of the epoch.</p>
</div>
<div class="section" id="fail-safe-mechanism">
<h5>4. Fail-safe mechanism<a class="headerlink" href="#fail-safe-mechanism" title="Permalink to this headline">¶</a></h5>
<p>For each stem-phase transaction that was sent or relayed, <code class="docutils literal notranslate"><span class="pre">NodeX</span></code>
tracks whether it is seen again as a fluff-phase transaction within some
random amount of time. If not, the node fluffs the transaction itself.</p>
<p>This expiration timer is set by each stem-node upon receiving a
transaction to forward, and is chosen randomly. Nodes are initialized
with a timeout parameter Tbase. As per equation (7) in the paper, when a
stem-node <em>v</em> receives a transaction, it sets an expiration time
Tout(v):</p>
<p>Tout(v) ~ current_time + exp(1/Tbase)</p>
<p>If the transaction is not received again by relay v before the expiry of
Tout(v), it broadcasts the message using diffusion. This approach means
that the first stem-node to broadcast is approximately uniformly
selected among all stem-nodes who have seen the message, rather than the
originating node.</p>
<p>The paper also proceeds to specify the size of the initiating time out
parameter Tbase as part of <code class="docutils literal notranslate"><span class="pre">Proposition</span> <span class="pre">3</span></code> in the paper:</p>
<blockquote>
<div><p>Proposition3. For a timeout parameter</p>
<p>Tbase ≥ (−k(k−1)δhop) / 2 log(1−ε ),</p>
<p>where <code class="docutils literal notranslate"><span class="pre">k</span></code>, <code class="docutils literal notranslate"><span class="pre">ε</span></code> are parameters and δhop is the time between each
hop (e.g., network and/or internal node latency), transactions travel
for <code class="docutils literal notranslate"><span class="pre">k</span></code> hops without any peer initiating diffusion with a
probability of at least <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">−</span> <span class="pre">ε</span></code>.</p>
</div></blockquote>
</div>
</div>
</div>
</div>
<div class="section" id="dandelion-in-grin">
<h2>Dandelion in Grin<a class="headerlink" href="#dandelion-in-grin" title="Permalink to this headline">¶</a></h2>
<div class="section" id="objectives">
<h3>Objectives<a class="headerlink" href="#objectives" title="Permalink to this headline">¶</a></h3>
<p>There are two main motives behind why Dandelion is included in Grin:</p>
<ol class="arabic simple">
<li><p><strong>Act as a countermeasure against mass de-anonymization attacks.</strong>
Similar to Bitcoin, the Grin P2P network would be vulnerable to
attackers deploying malicious “super-nodes” connecting to most peers
on the network and monitoring transactions as they become diffused by
their honest peers. This would allow a motivated actor to infer with
a high degree of probability from which peer (IP address)
transactions originate from, having negative privacy consequences.</p></li>
<li><p><strong>Aggregate transactions before they are being broadcasted to the
entire network.</strong> This is a benefit to blockchains that enable
non-interactive CoinJoins on the protocol level, such as
Mimblewimble. Despite its good privacy features, some input and
output linking is still possible in Mimblewimble and Grin.[4] If you
know which input spends to which output, it is possible to construct
a (very limited) transaction graph and follow a chain of transaction
outputs (TXOs) as they are being spent. Aggregating transactions make
this more difficult to carry out, as it becomes less clear which
input spends to which output (Figure 3). In order for this to be
effective, there needs to be a large anonymity set, i.e. many
transactions to aggregate a transaction with. Dandelion enables this
aggregation to occur before transactions are fluffed and diffused to
the entire network. This adds obfuscation to the transaction graph,
as a malicious observer who is not participating in the stemming or
fluffing would not only need to figure out from where a transaction
originated, but also which TXOs out of a larger group should be
attributed to the originating transaction.</p></li>
</ol>
<p><strong>Figure 3.</strong> Aggregating transactions</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mf">3.1</span> <span class="n">Transactions</span> <span class="p">(</span><span class="ow">not</span> <span class="n">aggregated</span><span class="p">)</span>
<span class="o">---------------------------------------------</span>
<span class="n">TX1</span>     <span class="n">INPUT_A</span> <span class="n">______________</span> <span class="n">OUTPUT_X</span>
                        <span class="o">|</span><span class="n">_____</span> <span class="n">OUTPUT_Y</span>

                        <span class="n">KERNEL</span> <span class="mi">1</span>
<span class="o">---------------------------------------------</span>
<span class="n">TX2</span>     <span class="n">INPUT_B</span> <span class="n">______________</span> <span class="n">OUTPUT_Z</span>
        <span class="n">INPUT_C</span> <span class="n">________</span><span class="o">|</span>

                        <span class="n">KERNEL</span> <span class="mi">2</span>
<span class="o">---------------------------------------------</span>

<span class="mf">3.2</span> <span class="n">Transactions</span> <span class="p">(</span><span class="n">aggregated</span><span class="p">)</span>
<span class="o">---------------------------------------------</span>
<span class="n">TX1</span><span class="o">+</span><span class="mi">2</span>   <span class="n">INPUT_A</span> <span class="n">______________</span> <span class="n">OUTPUT_X</span>
        <span class="n">INPUT_B</span> <span class="n">________</span><span class="o">|</span><span class="n">_____</span> <span class="n">OUTPUT_Y</span>
        <span class="n">INPUT_C</span> <span class="n">________</span><span class="o">|</span><span class="n">_____</span> <span class="n">OUTPUT_Z</span>

                        <span class="n">KERNEL</span> <span class="mi">1</span>
                        <span class="n">KERNEL</span> <span class="mi">2</span>
<span class="o">---------------------------------------------</span>
</pre></div>
</div>
</div>
<div class="section" id="current-implementation">
<h3>Current implementation<a class="headerlink" href="#current-implementation" title="Permalink to this headline">¶</a></h3>
<p>Grin implements a simplified version of the Dandelion++ protocol. It’s
been improved several times, most recently in version 1.1.0 [5].</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">DandelionEpoch</span></code> tracks a node’s current epoch. This is
configurable via <code class="docutils literal notranslate"><span class="pre">epoch_secs</span></code> with default epoch set to last for 10
minutes. Epochs are set and tracked by nodes individually.</p></li>
<li><p>At the beginning of an epoch, the node chooses a single connected
peer at random to use as their outbound relay.</p></li>
<li><p>At the beginning of an epoch, the node makes a decision whether to be
in stem mode or in fluff mode. This decision lasts for the duration
of the epoch. By default, this is a random choice, with the
probability to be in stem mode set to 90%, which implies a fluff mode
probability, <code class="docutils literal notranslate"><span class="pre">q</span></code> of 10%. The probability is configurable via
<code class="docutils literal notranslate"><span class="pre">DANDELION_STEM_PROBABILITY</span></code>. The number of expected stem hops a
transaction does before arriving to a fluff node is
<code class="docutils literal notranslate"><span class="pre">1/q</span> <span class="pre">=</span> <span class="pre">1/0.1</span> <span class="pre">=</span> <span class="pre">10</span></code>.</p></li>
<li><p>Any transactions received from inbound connected nodes or
transactions originated from the node itself are first added to the
node’s <code class="docutils literal notranslate"><span class="pre">stempool</span></code>, which is a list of stem transactions, that each
node keeps track of individually. Transactions are removed from the
stempool if:</p>
<ul class="simple">
<li><p>The node fluffs the transaction itself.</p></li>
<li><p>The node sees the transaction in question propagated through
regular diffusion, i.e. from a different peer having “fluffed” it.</p></li>
<li><p>The node receives a block containing this transaction, meaning
that the transaction was propagated and included in a block.</p></li>
</ul>
</li>
<li><p>For each transaction added to the stempool, the node sets an <em>embargo
timer</em>. This is set by default to 180 seconds, and is configurable
via <code class="docutils literal notranslate"><span class="pre">DANDELION_EMBARGO_SECS</span></code>.</p></li>
<li><p>Regardless of whether the node is in fluff or stem mode, any
transactions generated from the node itself are forwarded onwards to
their relay node as a stem transaction.[6]</p></li>
<li><p>A <code class="docutils literal notranslate"><span class="pre">dandelion_monitor</span></code> runs every 10 seconds and handles tasks.</p></li>
<li><p>If the node is in <strong>stem mode</strong>, then:</p>
<ol class="arabic simple">
<li><p>After being added to the stempool, received stem transactions are
forwarded onto the their relay node as a stem transaction.</p></li>
<li><p>As peers connect at random, it is possible they create a circular
loop of connected stem mode nodes (i.e. <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">-&gt;</span> <span class="pre">B</span> <span class="pre">-&gt;</span> <span class="pre">C</span> <span class="pre">-&gt;</span> <span class="pre">A</span></code>).
Therefore, if a node receives a stem transaction from an inbound
node that already exists in its own stempool, it will fluff it,
broadcasting it using regular diffusion.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dandelion_monitor</span></code> checks for transactions in the node’s
stempool with an expired embargo timer, and broadcast those
individually.</p></li>
</ol>
</li>
<li><p>If the node is in <strong>fluff mode</strong>, then:</p>
<ol class="arabic simple">
<li><p>Transactions received from inbound nodes are kept in the stempool.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dandelion_monitor</span></code> checks in the stempool whether any
transactions are older than 30 seconds (configurable as
<code class="docutils literal notranslate"><span class="pre">DANDELION_AGGREGATION_SECS</span></code>). If so, these are aggregated and
then fluffed. Otherwise no action is taken, allowing for more stem
transactions to aggregate in the stempool in time for the next
triggering of <code class="docutils literal notranslate"><span class="pre">dandelion_monitor</span></code>.</p></li>
<li><p>At the expiry of an epoch, all stem transactions remaining in the
stem pool are aggregated and fluffed.</p></li>
</ol>
</li>
</ol>
</div>
<div class="section" id="known-limitations">
<h3>Known limitations<a class="headerlink" href="#known-limitations" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>2-regular graphs are used rather than 4-regular graphs as proposed by
the paper. It’s not clear what impact this has, the paper suggests a
trade-off between general linkability of transactions and protection
against adversaries who know the entire network graph.</p></li>
<li><p>Unlike the Dandelion++ paper, the embargo timer is by default
identical across all nodes. This means that during a black-hole
attack where a malicious node withholds transactions, the node most
likely to have its embargo timer expire and fluff the transaction
will be the originating node, therefore exposing itself.</p></li>
</ul>
</div>
<div class="section" id="future-work">
<h3>Future work<a class="headerlink" href="#future-work" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>Randomized embargo timer according to the recommendations of the
paper to make it more random which node fluffs an expired
transaction.</p></li>
<li><p>Evaluation of whether 4-regular graphs are preferred over 2-regular
line graphs.</p></li>
<li><p>Simulation of the current implementation to understand performance.</p></li>
<li><p>Improved understanding of the benefits of transaction aggregation
prior to fluffing.</p></li>
</ul>
</div>
</div>
<div class="section" id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>[1] (Sigmetrics 2018) <a class="reference external" href="https://arxiv.org/abs/1805.11060">Dandelion++: Lightweight Cryptocurrency
Networking with Formal Anonymity
Guarantees</a></p></li>
<li><p>[2] (Sigmetrics 2017) <a class="reference external" href="https://arxiv.org/abs/1701.04439">Dandelion: Redesigning the Bitcoin Network for
Anonymity</a></p></li>
<li><p>[3] <a class="reference external" href="https://github.com/dandelion-org/bips/blob/master/bip-dandelion.mediawiki">Dandelion
BIP</a></p></li>
<li><p>[4] <a class="reference external" href="https://github.com/mimblewimble/docs/wiki/Grin-Privacy-Primer">Grin Privacy
Primer</a></p></li>
<li><p>[5] <a class="reference external" href="https://github.com/mimblewimble/grin/pull/2628">#2628: Dandelion++
Rewrite</a></p></li>
<li><p>[6] <a class="reference external" href="https://github.com/mimblewimble/grin/pull/2876">#2876: Always stem local txs if configured that way (unless
explicitly
fluffed)</a></p></li>
</ul>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, Grin Developers

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  
<div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
    <span class="fa fa-book fa-element"> RTD </span>

    <span class="fa fa-element">
    <input class="container_toggle" type="checkbox" id="switch" name="mode">
    <label for="switch"></label>
    </span>

    <span class="fa fa-v fa-element"> v:  <span class="fa fa-caret-down"></span></span>

    </span>
    <div class="rst-other-versions">
        <dl>
            <dt>Versions</dt> 
        </dl>
        <dl>
            <dt>Downloads</dt> 
        </dl>
        <dl>
            
            <dt>On Read the Docs</dt>
            <dd>
                <a href="///projects//?fromdocs=">Project Home</a>
            </dd>
            <dd>
                <a href="///builds//?fromdocs=">Builds</a>
            </dd>
        </dl>
    </div>
</div>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>