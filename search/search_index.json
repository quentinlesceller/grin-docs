{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the Grin Documentation Introduction to Mimblewimble and Grin Mimblewimble is a blockchain format and protocol that provides extremely good scalability, privacy and fungibility by relying on strong cryptographic primitives. It addresses gaps existing in almost all current blockchain implementations. Grin is an open source software project that implements a Mimblewimble blockchain and fills the gaps required for a full blockchain and cryptocurrency deployment. Here's an overview: Clean and minimal implementation, and aiming to stay as such. Follows the MimbleWimble protocol, which provides great anonymity and scaling characteristics. Cuckoo Cycle proof of work. Relatively fast block time: one minute. Fixed block reward over time with a decreasing dilution. Transaction fees are based on the number of Outputs created/destroyed and total transaction size. Smooth curve for difficulty adjustments. Goal and Characteristics Privacy by Default This enables complete fungibility without precluding the ability to selectively disclose information as needed. Scales mostly with the number of users and minimally with the number of transactions (<100 byte kernel), resulting in a large space saving compared to other blockchains. Strong and proven cryptography Mimblewimble only relies on Elliptic Curve Cryptography which has been tried and tested for decades. Design simplicity Easy to audit and maintain over time Community driven Community driven, encouraging mining decentralization. No ICO, Founder reward, pre-mine or aidrop.","title":"Home"},{"location":"#welcome-to-the-grin-documentation","text":"","title":"Welcome to the Grin Documentation"},{"location":"#introduction-to-mimblewimble-and-grin","text":"Mimblewimble is a blockchain format and protocol that provides extremely good scalability, privacy and fungibility by relying on strong cryptographic primitives. It addresses gaps existing in almost all current blockchain implementations. Grin is an open source software project that implements a Mimblewimble blockchain and fills the gaps required for a full blockchain and cryptocurrency deployment. Here's an overview: Clean and minimal implementation, and aiming to stay as such. Follows the MimbleWimble protocol, which provides great anonymity and scaling characteristics. Cuckoo Cycle proof of work. Relatively fast block time: one minute. Fixed block reward over time with a decreasing dilution. Transaction fees are based on the number of Outputs created/destroyed and total transaction size. Smooth curve for difficulty adjustments.","title":"Introduction to Mimblewimble and Grin"},{"location":"#goal-and-characteristics","text":"","title":"Goal and Characteristics"},{"location":"#privacy-by-default","text":"This enables complete fungibility without precluding the ability to selectively disclose information as needed. Scales mostly with the number of users and minimally with the number of transactions (<100 byte kernel), resulting in a large space saving compared to other blockchains.","title":"Privacy by Default"},{"location":"#strong-and-proven-cryptography","text":"Mimblewimble only relies on Elliptic Curve Cryptography which has been tried and tested for decades.","title":"Strong and proven cryptography"},{"location":"#design-simplicity","text":"Easy to audit and maintain over time","title":"Design simplicity"},{"location":"#community-driven","text":"Community driven, encouraging mining decentralization. No ICO, Founder reward, pre-mine or aidrop.","title":"Community driven"},{"location":"example/","text":"Full example from sanic import Sanic from sanic.response import json from sanic_camelcase_middleware import Camelize app = Sanic(__name__) Camelize(app) @app.route(\"/post\", methods=[\"POST\"]) async def test(request): return json(\"is_camelcase\": True, \"message\": request.json}) if __name__ == \"__main__\": app.run(host=\"0.0.0.0\", port=8000)","title":"Full example"},{"location":"example/#full-example","text":"from sanic import Sanic from sanic.response import json from sanic_camelcase_middleware import Camelize app = Sanic(__name__) Camelize(app) @app.route(\"/post\", methods=[\"POST\"]) async def test(request): return json(\"is_camelcase\": True, \"message\": request.json}) if __name__ == \"__main__\": app.run(host=\"0.0.0.0\", port=8000)","title":"Full example"},{"location":"getting-started/","text":"Getting Started Full code on github . Install pip install sanic_camelcase_middelware Dependencies pyhumps sanic Example from sanic import Sanic from sanic_camelcase_middleware import Camelize app = Sanic(__name__) Camelize(app)","title":"Getting started"},{"location":"getting-started/#getting-started","text":"Full code on github .","title":"Getting Started"},{"location":"getting-started/#install","text":"pip install sanic_camelcase_middelware","title":"Install"},{"location":"getting-started/#dependencies","text":"pyhumps sanic","title":"Dependencies"},{"location":"getting-started/#example","text":"from sanic import Sanic from sanic_camelcase_middleware import Camelize app = Sanic(__name__) Camelize(app)","title":"Example"},{"location":"integrations/intro/","text":"","title":"Intro"},{"location":"technical/blocks-and-headers/","text":"Blocks and Block headers Read this in other languages: Korean . Node receives block from peer (normal operation) During normal operation the Grin node will receive blocks from connected peers via the gossip protocol. If the block and the block header validate successfully then both are saved to the store. The header head is updated to point to the latest block header and the block head is updated to point to the latest block. Node syncs for first time [tbd] Node falls behind (sync to catch up with peer) Periodically the node will compare its current total_difficulty to the total_difficulty of all connected peers. If a peer with higher total_difficulty is seen then we attempt to sync to this peer (most_work_peer). If multiple most_work_peers exist then one is selected at random. The sync process is initiated by building a \"locator\" based on current known chain state (see [tbd] for more info on the locator) and requesting a list of headers from the peer, passing the locator to help select appropriate headers. On receiving the list of headers the node will validate them and then save them to the store. For each header the header head will be updated to reflect the most recent header. The node will then request each \"missing\" block by comparing the header chain (back from the header head) to the current block chain (back from the block head). Blocks are requested from peers with larger total_difficulty than the node. This process is repeated until no peers are seen with higher total_difficulty and both heads are in a consistent state (pointing to the same head/block). A new peer connects with a previously unknown longest fork Node falls significantly behind (>500 blocks) Currently we limit header retrieval to batches of approx 500 headers (512?). We need to describe (and think through) exactly what happens when after we receive the first batch of 500 headers such that we have a new header chain but the total_difficulty of this new chain is not sufficient to overtake the existing chain. What happens here? Node successfully mines a block [tbd] Two competing blocks are mined (temporary fork) [tbd]","title":"Blocks and Headers"},{"location":"technical/blocks-and-headers/#blocks-and-block-headers","text":"Read this in other languages: Korean .","title":"Blocks and Block headers"},{"location":"technical/blocks-and-headers/#node-receives-block-from-peer-normal-operation","text":"During normal operation the Grin node will receive blocks from connected peers via the gossip protocol. If the block and the block header validate successfully then both are saved to the store. The header head is updated to point to the latest block header and the block head is updated to point to the latest block.","title":"Node receives block from peer (normal operation)"},{"location":"technical/blocks-and-headers/#node-syncs-for-first-time","text":"[tbd]","title":"Node syncs for first time"},{"location":"technical/blocks-and-headers/#node-falls-behind-sync-to-catch-up-with-peer","text":"Periodically the node will compare its current total_difficulty to the total_difficulty of all connected peers. If a peer with higher total_difficulty is seen then we attempt to sync to this peer (most_work_peer). If multiple most_work_peers exist then one is selected at random. The sync process is initiated by building a \"locator\" based on current known chain state (see [tbd] for more info on the locator) and requesting a list of headers from the peer, passing the locator to help select appropriate headers. On receiving the list of headers the node will validate them and then save them to the store. For each header the header head will be updated to reflect the most recent header. The node will then request each \"missing\" block by comparing the header chain (back from the header head) to the current block chain (back from the block head). Blocks are requested from peers with larger total_difficulty than the node. This process is repeated until no peers are seen with higher total_difficulty and both heads are in a consistent state (pointing to the same head/block).","title":"Node falls behind (sync to catch up with peer)"},{"location":"technical/blocks-and-headers/#a-new-peer-connects-with-a-previously-unknown-longest-fork","text":"","title":"A new peer connects with a previously unknown longest fork"},{"location":"technical/blocks-and-headers/#node-falls-significantly-behind-500-blocks","text":"Currently we limit header retrieval to batches of approx 500 headers (512?). We need to describe (and think through) exactly what happens when after we receive the first batch of 500 headers such that we have a new header chain but the total_difficulty of this new chain is not sufficient to overtake the existing chain. What happens here?","title":"Node falls significantly behind (&gt;500 blocks)"},{"location":"technical/blocks-and-headers/#node-successfully-mines-a-block","text":"[tbd]","title":"Node successfully mines a block"},{"location":"technical/blocks-and-headers/#two-competing-blocks-are-mined-temporary-fork","text":"[tbd]","title":"Two competing blocks are mined (temporary fork)"},{"location":"technical/grin4bitcoiners/","text":"Grin for Bitcoiners Privacy and Fungibility There are 3 main properties of Grin transactions that make them private: There are no addresses. There are no amounts. 2 transactions, one spending the other, can be merged in a block to form only one, removing all intermediary information. The 2 first properties mean that all transactions are indistinguishable from one another. Unless you directly participated in the transaction, all inputs and outputs look like random pieces of data (in lingo, they're all random curve points). Moreover, there are no more transactions in a block. A Grin block looks just like one giant transaction and all original association between inputs and outputs is lost. Scalability As explained in the previous section, thanks to the Mimblewimble transaction and block format we can merge transactions when an output is directly spent by the input of another. It's as if when Alice gives money to Bob, and then Bob gives it all to Carol, Bob was never involved and his transaction is actually never even seen on the blockchain. Pushing that further, between blocks, most outputs end up being spent sooner or later by another input. So all spent outputs can be safely removed . And the whole blockchain can be stored, downloaded and fully verified in just a few gigabytes or less (assuming a number of transactions similar to bitcoin). This means that the Grin blockchain scales with the number of users (unspent outputs), not the number of transactions. At the moment, there is one caveat to that: a small piece of data (called a kernel , about 100 bytes) needs to stay around for each transaction. But we're working on optimizing that as well. Scripting Maybe you've heard that Mimblewimble doesn't support scripts. And in some way, that's true. But thanks to cryptographic trickery, many contracts that in Bitcoin would require a script can be achieved with Grin using properties of Elliptic Curve Cryptography. So far, we know how to do: Multi-signature transactions. Atomic swaps. Time-locked transactions and outputs. Lightning Network Emission Rate Bitcoin's 10 minute block time has its initial 50 btc reward cut in half every 4 years until there are 21 million bitcoin in circulation. Grin's emission rate is linear, meaning it never drops. The block reward is currently set at 60 grin with a block goal of 60 seconds. This still works because 1) dilution trends toward zero and 2) a non-negligible amount of coins gets lost or destroyed every year. FAQ Wait, what!? No address? Nope, no address. All outputs in Grin are unique and have no common data with any previous output. Instead of relying on a known address to send money, transactions have to be built interactively, with two (or more) wallets exchanging data with one another. This interaction does not require both parties to be online at the same time . Practically speaking, there are many ways for two programs to interact privately and securely. This interaction could even take place over email or Signal (or carrier pigeons). If transaction information gets removed, can I just cheat and create money? No, and this is where Mimblewimble and Grin shine. Confidential transactions are a form of homomorphic encryption . Without revealing any amount, Grin can verify that the sum of all transaction inputs equal the sum of transaction outputs, plus the fee. Going even further, comparing the sum of all money created by mining with the total sum of money that's being held, Grin nodes can check the correctness of the total money supply. If I listen to transaction relay, can't I just figure out who they belong to before being cut-through? You can figure out which outputs are being spent by which transaction, but the trail of data stops here. All inputs and outputs look like random pieces of data, so you can't tell if the money was transferred, still belongs to the same person, which output is the actual transfer and which is the change, etc. Grin transactions are built with no identifiable piece of information . In addition, Grin leverages Dandelion relay , which provides additional anonymity as to which IP or client the transaction originated from, and allows for transactions to be aggregated. What about the quantum computaggedon? In every Grin output, we also include a bit of hashed data, which is quantum safe. If quantum computing was to become a reality, we can safely introduce additional verification that would protect existing coins from being hacked. How does all this magic work? See our technical introduction to get started.","title":"Grin4Bitcoiners"},{"location":"technical/grin4bitcoiners/#grin-for-bitcoiners","text":"","title":"Grin for Bitcoiners"},{"location":"technical/grin4bitcoiners/#privacy-and-fungibility","text":"There are 3 main properties of Grin transactions that make them private: There are no addresses. There are no amounts. 2 transactions, one spending the other, can be merged in a block to form only one, removing all intermediary information. The 2 first properties mean that all transactions are indistinguishable from one another. Unless you directly participated in the transaction, all inputs and outputs look like random pieces of data (in lingo, they're all random curve points). Moreover, there are no more transactions in a block. A Grin block looks just like one giant transaction and all original association between inputs and outputs is lost.","title":"Privacy and Fungibility"},{"location":"technical/grin4bitcoiners/#scalability","text":"As explained in the previous section, thanks to the Mimblewimble transaction and block format we can merge transactions when an output is directly spent by the input of another. It's as if when Alice gives money to Bob, and then Bob gives it all to Carol, Bob was never involved and his transaction is actually never even seen on the blockchain. Pushing that further, between blocks, most outputs end up being spent sooner or later by another input. So all spent outputs can be safely removed . And the whole blockchain can be stored, downloaded and fully verified in just a few gigabytes or less (assuming a number of transactions similar to bitcoin). This means that the Grin blockchain scales with the number of users (unspent outputs), not the number of transactions. At the moment, there is one caveat to that: a small piece of data (called a kernel , about 100 bytes) needs to stay around for each transaction. But we're working on optimizing that as well.","title":"Scalability"},{"location":"technical/grin4bitcoiners/#scripting","text":"Maybe you've heard that Mimblewimble doesn't support scripts. And in some way, that's true. But thanks to cryptographic trickery, many contracts that in Bitcoin would require a script can be achieved with Grin using properties of Elliptic Curve Cryptography. So far, we know how to do: Multi-signature transactions. Atomic swaps. Time-locked transactions and outputs. Lightning Network","title":"Scripting"},{"location":"technical/grin4bitcoiners/#emission-rate","text":"Bitcoin's 10 minute block time has its initial 50 btc reward cut in half every 4 years until there are 21 million bitcoin in circulation. Grin's emission rate is linear, meaning it never drops. The block reward is currently set at 60 grin with a block goal of 60 seconds. This still works because 1) dilution trends toward zero and 2) a non-negligible amount of coins gets lost or destroyed every year.","title":"Emission Rate"},{"location":"technical/grin4bitcoiners/#faq","text":"","title":"FAQ"},{"location":"technical/grin4bitcoiners/#wait-what-no-address","text":"Nope, no address. All outputs in Grin are unique and have no common data with any previous output. Instead of relying on a known address to send money, transactions have to be built interactively, with two (or more) wallets exchanging data with one another. This interaction does not require both parties to be online at the same time . Practically speaking, there are many ways for two programs to interact privately and securely. This interaction could even take place over email or Signal (or carrier pigeons).","title":"Wait, what!? No address?"},{"location":"technical/grin4bitcoiners/#if-transaction-information-gets-removed-can-i-just-cheat-and-create-money","text":"No, and this is where Mimblewimble and Grin shine. Confidential transactions are a form of homomorphic encryption . Without revealing any amount, Grin can verify that the sum of all transaction inputs equal the sum of transaction outputs, plus the fee. Going even further, comparing the sum of all money created by mining with the total sum of money that's being held, Grin nodes can check the correctness of the total money supply.","title":"If transaction information gets removed, can I just cheat and create money?"},{"location":"technical/grin4bitcoiners/#if-i-listen-to-transaction-relay-cant-i-just-figure-out-who-they-belong-to-before-being-cut-through","text":"You can figure out which outputs are being spent by which transaction, but the trail of data stops here. All inputs and outputs look like random pieces of data, so you can't tell if the money was transferred, still belongs to the same person, which output is the actual transfer and which is the change, etc. Grin transactions are built with no identifiable piece of information . In addition, Grin leverages Dandelion relay , which provides additional anonymity as to which IP or client the transaction originated from, and allows for transactions to be aggregated.","title":"If I listen to transaction relay, can't I just figure out who they belong to before being cut-through?"},{"location":"technical/grin4bitcoiners/#what-about-the-quantum-computaggedon","text":"In every Grin output, we also include a bit of hashed data, which is quantum safe. If quantum computing was to become a reality, we can safely introduce additional verification that would protect existing coins from being hacked.","title":"What about the quantum computaggedon?"},{"location":"technical/grin4bitcoiners/#how-does-all-this-magic-work","text":"See our technical introduction to get started.","title":"How does all this magic work?"},{"location":"technical/switch-commitments/","text":"Introduction to Switch Commitments Read this in other languages: \u7b80\u4f53\u4e2d\u6587 . General introduction In cryptography a Commitment (or commitment scheme ) refers to a concept which can be imagined like a box with a lock. You can put something into the box (for example a piece of a paper with a secret number written on it), lock it and give it to another person (or the public). The other person doesn't know yet what's the secret number in the box, but if you decide to publish your secret number later in time and want to prove that this really is the secret which you came up with in the first place (and not a different one) you can prove this simply by giving the key of the box to the other person. They can unlock the box, compare the secret within the box with the secret you just published and can be sure that you didn't change your secret since you locked it. You \" committed \" to the secret number beforehand, meaning you cannot change it between the time of commitment and the time of revealing. Examples Hash Commitment A simple commitment scheme can be realized with a cryptographic hash function. For example: Alice and Bob want to play \"Guess my number\" and Alice comes up with with her really secret number 29 which Bob has to guess in the game, then before the game starts, Alice calculates: hash( 29 + r ) and publishes the result to Bob. The r is a randomly chosen Blinding Factor which is needed because otherwise Bob could just try hashing all the possible numbers for the game and compare the hashes. When the game is finished, Alice simply needs to publish her secret number 29 and the blinding factor r and Bob can calculate the hash himself and easily verify that Alice did not change the secret number during the game. Pedersen Commitment Other, more advanced commitment schemes can have additional properties. For example Mimblewimble and Confidential Transactions (CT) make heavy use of Pedersen Commitments , which are homomorphic commitments. Homomorphic in this context means that (speaking in the \"box\" metaphor from above) you can take two of these locked boxes ( box1 and box2 ) and somehow \" add \" them together, so that you get a single box as result (which still is locked), and if you open this single box later (like in the examples before) the secret it contains, is the sum of the secrets from box1 and box2 . While this \"box\" metaphor no longer seems to be reasonable in the real-world this is perfectly possible using the properties of operations on elliptic curves. Look into Introduction to Mimblewimble for further details on Pedersen Commitments and how they are used in Grin. Properties of commitment schemes: In general for any commitment scheme we can identify two important properties which can be weaker or stronger, depending on the type of commitment scheme: Hidingness (or Confidentiality): How good is the commitment scheme protecting the secret commitment. Or speaking in terms of our example from above: what would an attacker need to open the box (and learn the secret number) without having the key to unlock it? Bindingness: Is it possible at all (or how hard would it be) for an attacker to somehow find a different secret, which would produce the same commitment, so that the attacker could later open the commitment to a different secret, thus breaking the binding of the commitment. Security of these properties: For these two properties different security levels can be identified. The two most important combinations of these are perfectly binding and computationally hiding commitment schemes and computationally binding and perfectly hiding commitment schemes \" Computationally \" binding or hiding means that the property (bindingness/hidingness) is secured by the fact that the underlying mathematical problem is too hard to be solved with existing computing power in reasonable time (i.e. not breakable today as computational resources are bound in the real world). \" Perfectly \" binding or hiding means that even with infinite computing power it would be impossible to break the property (bindingness/hidingness). Mutual exclusivity: It is important to realize that it's impossible that any commitment scheme can be perfectly binding and perfectly hiding at the same time. This can be easily shown with a thought experiment: Imagine an attacker having infinite computing power, he could simply generate a commitment for all possible values (and blinding factors) until finding a pair that outputs the same commitment. If we further assume the commitment scheme is perfectly binding (meaning there cannot be two different values leading to the same commitment) this uniquely would identify the value within the commitment, thus breaking the hidingness. The same is true the other way around. If a commitment scheme is perfectly hiding there must exist several input values resulting in the same commitment (otherwise an attacker with infinite computing power could just try all possible values as described above). This concludes that the commitment scheme cannot be perfectly binding . Always a compromise The key take-away point is this: it's always a compromise , you can never have both properties ( hidingness and bindingness ) with perfect security. If one is perfectly secure then the other can be at most computationally secure (and the other way around). Considerations for cryptocurrencies Which roles do these properties play in the design of cryptocurrencies? Hidingness : In privacy oriented cryptocurrencies like Grin, commitment schemes are used to secure the contents of transactions. The sender commits to an amount of coins he sends, but for the general public the concrete amount should remain private (protected by the hidingness property of the commitment scheme). Bindingness : At the same time no transaction creator should ever be able to change his commitment to a different transaction amount later in time. If this would be possible, an attacker could spend more coins than previously committed to in an UTXO (unspent transaction output) and therefore inflate coins out of thin air. Even worse, as the amounts are hidden, this could go undetected. So there is a valid interest in having both of these properties always secured and never be violated. Even with the intent being that both of these properties will hold for the lifetime of a cryptocurrency, still a choice has to be made about which commitment scheme to use. A hard choice? Which one of these two properties needs to be perfectly safe and for which one it would be sufficient to be computationally safe? Or in other words: in case of a disaster, if the commitment scheme unexpectedly gets broken, which one of the two properties should be valued higher? Economical soundness (no hidden inflation possible) or ensured privacy (privacy will be preserved)? This seems like a hard to choice to make. If we look closer into this we realize that the commitment scheme only needs to be perfectly binding at the point in time when the scheme actually gets broken. Until then it will be safe even if it's only computationally binding. At the same time a privacy-oriented cryptocurrency needs to ensure the hidingness property forever . Unlike the binding property, which only is important at the time when a transaction is created and will not affect past transactions, the hidingness property must be ensured at all times. Otherwise, in the unfortunate case should the commitment scheme be broken, an attacker could go back in the chain and unblind past transactions, thus break the privacy property retroactively. Properties of Pedersen Commitments Pedersen Commitments are computationally binding and perfectly hiding as for a given commitment to the value v : v*H + r*G there may exist a pair of different values r1 and v1 such that the sum will be the same. Even if you have infinite computing power and could try all possible values, you would not be able to tell which one is the original one (thus perfectly hiding ). Introducing Switch Commitments So what can be done if the bindingness of the Pedersen Commitment unexpectedly gets broken? In general a cryptocurrency confronted with a broken commitment scheme could choose to change the scheme in use, but the problem with this approach would be that it requires to create new transaction outputs using the new scheme to make funds secure again. This would require every coin holder to move his coins into new transaction outputs. If coins are not moved into new outputs, they will not profit from the security of the new commitment scheme. Also, this has to happen before the scheme gets actually broken in the wild, otherwise the existing UTXOs no longer can be assumed to contain correct values. In this situation Switch Commitments offer a neat solution. These type of commitments allow changing the properties of the commitments just by changing the revealing / validating procedure without changing the way commitments are created. (You \" switch \" to a new validation scheme which is backwards compatible with commitments created long before the actual \" switch \"). How does this work in detail First let's introduce a new commitment scheme: The ElGamal commitment scheme is a commitment scheme similiar to Pedersen Commitments and it's perfectly binding (but only computationally hiding as we can never have both). It looks very similar to a Pedersen Commitment, with the addition of a new element, calculated by multiplying the blinding factor r with another generator point J : v*H + r*G , r*J So if we store the additional field r*J and ignore it for now, we can treat it like Pedersen Commitments, until we decide to also validate the full ElGamal commitment at some time in future. This is exactly what was implemented in an earlier version of Grin , before mainnet was launched. In detail: the hashed value of r*J ( switch_commit_hash ) was added to the transaction output, but this came with the burden of increasing the size of each output by 32 bytes. Fortunately, later on the Mimblewimble mailinglist Tim Ruffing came up with a really beautiful idea (initially suggested by Pieter Wuille), which offers the same advantages but doesn't need this extra storage of an additional element per transaction output: The idea is the following: A normal Pedersen commitment looks like this: v*H + r*G ( v is value of the input/output, r is a truly random blinding factor, and H and G are two generator points on the elliptic curve). If we adapt this by having r not being random itself, but using another random number r' and create the Pedersen Commitment: v*H + r*G such that: r = r' + hash( v*H + r'*G , r'*J ) (using the additional third generation point J on the curve) then r still is perfectly valid as a blinding factor, as it's still randomly distributed, but now we see that the part within the brackets of the hash function ( v*H + r'*G , r'*J ) is an ElGamal commitment . This neat idea lead to the removal of the switch commitment hash from the outputs in this (and following) pull requests as now it could be easily included into the Pedersen Commitments. This is how it is currently implemented in Grin. Pedersen commitments are used for the Confidential Transaction but instead of choosing the blinding factor r only by random, it is calculated by adding the hash of an ElGamal commitment to a random r' (see here in main_impl.h#L267 ). In general switch commitments were first described in the paper \"Switch Commitments: A Safety Switch for Confidential Transactions\" ). The \"switch\" in the name comes from the fact that you can virtually flip a \"switch\" in the future and simply by changing the validation procedure you can change the strength of the bindingness and hidingness property of your commitments and this even works in a backwards compatible way with commitments created today. Conclusion Grin uses Pedersen Commitments - like other privacy cryptocurrencies do as well - with the only difference that the random blinding factor r is created using the ElGamal commitment scheme. This might not seem like a big change on a first look, but it provides an important safety measure: Pedersen Commitments are already perfectly hiding so whatever happens, privacy will never be at risk without requiring any action from users. But in case of a disaster if the bindingness of the commitment scheme gets broken, then switch commitments can be enabled (via a soft fork) requiring that all new transactions prove that their commitment is not breaking the bindingness by validating the full ElGamal commitment. But in this case users would still have a choice: they can decide to continue to create new transactions, even if this might compromise their privacy (only on their last UTXOs) as the ElGamal commitment scheme is only computationally hiding, but at least they would still have access to their coins or users can decide to just leave the money alone, walk away and make no more transactions (but preserve their privacy, as their old transactions only validated the Pedersen commitment which is perfectly hiding) There are many cases where a privacy leak is much more dangerous to one's life than some cryptocurrency might be worth. But this is a decision that should be left up to the individual user and switch commitments enable this type of choice. It should be made clear that this is a safety measure meant to be enabled in case of a disaster. If advances in computing would put the hardness of the discrete log problem in question, a lot of other cryptographic systems, including other cryptocurrencies, will be in urgent need of updating their primitives to a future-proof system. The switch commitments just provide an additional layer of security if the bindingness of Pedersen commitments ever breaks unexpectedly.","title":"Switch Commitments"},{"location":"technical/switch-commitments/#introduction-to-switch-commitments","text":"Read this in other languages: \u7b80\u4f53\u4e2d\u6587 .","title":"Introduction to Switch Commitments"},{"location":"technical/switch-commitments/#general-introduction","text":"In cryptography a Commitment (or commitment scheme ) refers to a concept which can be imagined like a box with a lock. You can put something into the box (for example a piece of a paper with a secret number written on it), lock it and give it to another person (or the public). The other person doesn't know yet what's the secret number in the box, but if you decide to publish your secret number later in time and want to prove that this really is the secret which you came up with in the first place (and not a different one) you can prove this simply by giving the key of the box to the other person. They can unlock the box, compare the secret within the box with the secret you just published and can be sure that you didn't change your secret since you locked it. You \" committed \" to the secret number beforehand, meaning you cannot change it between the time of commitment and the time of revealing.","title":"General introduction"},{"location":"technical/switch-commitments/#examples","text":"","title":"Examples"},{"location":"technical/switch-commitments/#hash-commitment","text":"A simple commitment scheme can be realized with a cryptographic hash function. For example: Alice and Bob want to play \"Guess my number\" and Alice comes up with with her really secret number 29 which Bob has to guess in the game, then before the game starts, Alice calculates: hash( 29 + r ) and publishes the result to Bob. The r is a randomly chosen Blinding Factor which is needed because otherwise Bob could just try hashing all the possible numbers for the game and compare the hashes. When the game is finished, Alice simply needs to publish her secret number 29 and the blinding factor r and Bob can calculate the hash himself and easily verify that Alice did not change the secret number during the game.","title":"Hash Commitment"},{"location":"technical/switch-commitments/#pedersen-commitment","text":"Other, more advanced commitment schemes can have additional properties. For example Mimblewimble and Confidential Transactions (CT) make heavy use of Pedersen Commitments , which are homomorphic commitments. Homomorphic in this context means that (speaking in the \"box\" metaphor from above) you can take two of these locked boxes ( box1 and box2 ) and somehow \" add \" them together, so that you get a single box as result (which still is locked), and if you open this single box later (like in the examples before) the secret it contains, is the sum of the secrets from box1 and box2 . While this \"box\" metaphor no longer seems to be reasonable in the real-world this is perfectly possible using the properties of operations on elliptic curves. Look into Introduction to Mimblewimble for further details on Pedersen Commitments and how they are used in Grin.","title":"Pedersen Commitment"},{"location":"technical/switch-commitments/#properties-of-commitment-schemes","text":"In general for any commitment scheme we can identify two important properties which can be weaker or stronger, depending on the type of commitment scheme: Hidingness (or Confidentiality): How good is the commitment scheme protecting the secret commitment. Or speaking in terms of our example from above: what would an attacker need to open the box (and learn the secret number) without having the key to unlock it? Bindingness: Is it possible at all (or how hard would it be) for an attacker to somehow find a different secret, which would produce the same commitment, so that the attacker could later open the commitment to a different secret, thus breaking the binding of the commitment.","title":"Properties of commitment schemes:"},{"location":"technical/switch-commitments/#security-of-these-properties","text":"For these two properties different security levels can be identified. The two most important combinations of these are perfectly binding and computationally hiding commitment schemes and computationally binding and perfectly hiding commitment schemes \" Computationally \" binding or hiding means that the property (bindingness/hidingness) is secured by the fact that the underlying mathematical problem is too hard to be solved with existing computing power in reasonable time (i.e. not breakable today as computational resources are bound in the real world). \" Perfectly \" binding or hiding means that even with infinite computing power it would be impossible to break the property (bindingness/hidingness).","title":"Security of these properties:"},{"location":"technical/switch-commitments/#mutual-exclusivity","text":"It is important to realize that it's impossible that any commitment scheme can be perfectly binding and perfectly hiding at the same time. This can be easily shown with a thought experiment: Imagine an attacker having infinite computing power, he could simply generate a commitment for all possible values (and blinding factors) until finding a pair that outputs the same commitment. If we further assume the commitment scheme is perfectly binding (meaning there cannot be two different values leading to the same commitment) this uniquely would identify the value within the commitment, thus breaking the hidingness. The same is true the other way around. If a commitment scheme is perfectly hiding there must exist several input values resulting in the same commitment (otherwise an attacker with infinite computing power could just try all possible values as described above). This concludes that the commitment scheme cannot be perfectly binding .","title":"Mutual exclusivity:"},{"location":"technical/switch-commitments/#always-a-compromise","text":"The key take-away point is this: it's always a compromise , you can never have both properties ( hidingness and bindingness ) with perfect security. If one is perfectly secure then the other can be at most computationally secure (and the other way around).","title":"Always a compromise"},{"location":"technical/switch-commitments/#considerations-for-cryptocurrencies","text":"Which roles do these properties play in the design of cryptocurrencies? Hidingness : In privacy oriented cryptocurrencies like Grin, commitment schemes are used to secure the contents of transactions. The sender commits to an amount of coins he sends, but for the general public the concrete amount should remain private (protected by the hidingness property of the commitment scheme). Bindingness : At the same time no transaction creator should ever be able to change his commitment to a different transaction amount later in time. If this would be possible, an attacker could spend more coins than previously committed to in an UTXO (unspent transaction output) and therefore inflate coins out of thin air. Even worse, as the amounts are hidden, this could go undetected. So there is a valid interest in having both of these properties always secured and never be violated. Even with the intent being that both of these properties will hold for the lifetime of a cryptocurrency, still a choice has to be made about which commitment scheme to use.","title":"Considerations for cryptocurrencies"},{"location":"technical/switch-commitments/#a-hard-choice","text":"Which one of these two properties needs to be perfectly safe and for which one it would be sufficient to be computationally safe? Or in other words: in case of a disaster, if the commitment scheme unexpectedly gets broken, which one of the two properties should be valued higher? Economical soundness (no hidden inflation possible) or ensured privacy (privacy will be preserved)? This seems like a hard to choice to make. If we look closer into this we realize that the commitment scheme only needs to be perfectly binding at the point in time when the scheme actually gets broken. Until then it will be safe even if it's only computationally binding. At the same time a privacy-oriented cryptocurrency needs to ensure the hidingness property forever . Unlike the binding property, which only is important at the time when a transaction is created and will not affect past transactions, the hidingness property must be ensured at all times. Otherwise, in the unfortunate case should the commitment scheme be broken, an attacker could go back in the chain and unblind past transactions, thus break the privacy property retroactively.","title":"A hard choice?"},{"location":"technical/switch-commitments/#properties-of-pedersen-commitments","text":"Pedersen Commitments are computationally binding and perfectly hiding as for a given commitment to the value v : v*H + r*G there may exist a pair of different values r1 and v1 such that the sum will be the same. Even if you have infinite computing power and could try all possible values, you would not be able to tell which one is the original one (thus perfectly hiding ).","title":"Properties of Pedersen Commitments"},{"location":"technical/switch-commitments/#introducing-switch-commitments","text":"So what can be done if the bindingness of the Pedersen Commitment unexpectedly gets broken? In general a cryptocurrency confronted with a broken commitment scheme could choose to change the scheme in use, but the problem with this approach would be that it requires to create new transaction outputs using the new scheme to make funds secure again. This would require every coin holder to move his coins into new transaction outputs. If coins are not moved into new outputs, they will not profit from the security of the new commitment scheme. Also, this has to happen before the scheme gets actually broken in the wild, otherwise the existing UTXOs no longer can be assumed to contain correct values. In this situation Switch Commitments offer a neat solution. These type of commitments allow changing the properties of the commitments just by changing the revealing / validating procedure without changing the way commitments are created. (You \" switch \" to a new validation scheme which is backwards compatible with commitments created long before the actual \" switch \").","title":"Introducing Switch Commitments"},{"location":"technical/switch-commitments/#how-does-this-work-in-detail","text":"First let's introduce a new commitment scheme: The ElGamal commitment scheme is a commitment scheme similiar to Pedersen Commitments and it's perfectly binding (but only computationally hiding as we can never have both). It looks very similar to a Pedersen Commitment, with the addition of a new element, calculated by multiplying the blinding factor r with another generator point J : v*H + r*G , r*J So if we store the additional field r*J and ignore it for now, we can treat it like Pedersen Commitments, until we decide to also validate the full ElGamal commitment at some time in future. This is exactly what was implemented in an earlier version of Grin , before mainnet was launched. In detail: the hashed value of r*J ( switch_commit_hash ) was added to the transaction output, but this came with the burden of increasing the size of each output by 32 bytes. Fortunately, later on the Mimblewimble mailinglist Tim Ruffing came up with a really beautiful idea (initially suggested by Pieter Wuille), which offers the same advantages but doesn't need this extra storage of an additional element per transaction output: The idea is the following: A normal Pedersen commitment looks like this: v*H + r*G ( v is value of the input/output, r is a truly random blinding factor, and H and G are two generator points on the elliptic curve). If we adapt this by having r not being random itself, but using another random number r' and create the Pedersen Commitment: v*H + r*G such that: r = r' + hash( v*H + r'*G , r'*J ) (using the additional third generation point J on the curve) then r still is perfectly valid as a blinding factor, as it's still randomly distributed, but now we see that the part within the brackets of the hash function ( v*H + r'*G , r'*J ) is an ElGamal commitment . This neat idea lead to the removal of the switch commitment hash from the outputs in this (and following) pull requests as now it could be easily included into the Pedersen Commitments. This is how it is currently implemented in Grin. Pedersen commitments are used for the Confidential Transaction but instead of choosing the blinding factor r only by random, it is calculated by adding the hash of an ElGamal commitment to a random r' (see here in main_impl.h#L267 ). In general switch commitments were first described in the paper \"Switch Commitments: A Safety Switch for Confidential Transactions\" ). The \"switch\" in the name comes from the fact that you can virtually flip a \"switch\" in the future and simply by changing the validation procedure you can change the strength of the bindingness and hidingness property of your commitments and this even works in a backwards compatible way with commitments created today.","title":"How does this work in detail"},{"location":"technical/switch-commitments/#conclusion","text":"Grin uses Pedersen Commitments - like other privacy cryptocurrencies do as well - with the only difference that the random blinding factor r is created using the ElGamal commitment scheme. This might not seem like a big change on a first look, but it provides an important safety measure: Pedersen Commitments are already perfectly hiding so whatever happens, privacy will never be at risk without requiring any action from users. But in case of a disaster if the bindingness of the commitment scheme gets broken, then switch commitments can be enabled (via a soft fork) requiring that all new transactions prove that their commitment is not breaking the bindingness by validating the full ElGamal commitment. But in this case users would still have a choice: they can decide to continue to create new transactions, even if this might compromise their privacy (only on their last UTXOs) as the ElGamal commitment scheme is only computationally hiding, but at least they would still have access to their coins or users can decide to just leave the money alone, walk away and make no more transactions (but preserve their privacy, as their old transactions only validated the Pedersen commitment which is perfectly hiding) There are many cases where a privacy leak is much more dangerous to one's life than some cryptocurrency might be worth. But this is a decision that should be left up to the individual user and switch commitments enable this type of choice. It should be made clear that this is a safety measure meant to be enabled in case of a disaster. If advances in computing would put the hardness of the discrete log problem in question, a lot of other cryptographic systems, including other cryptocurrencies, will be in urgent need of updating their primitives to a future-proof system. The switch commitments just provide an additional layer of security if the bindingness of Pedersen commitments ever breaks unexpectedly.","title":"Conclusion"},{"location":"technical/technical-introduction/","text":"Technical Introductionn to Mimblewimble Tongue Tying for Everyone This document is targeted at readers with a good understanding of blockchains and basic cryptography. With that in mind, we attempt to explain the technical buildup of Mimblewimble and how it's applied in Grin. We hope this document is understandable to most technically-minded readers. Our objective is to encourage you to get interested in Grin and contribute in any way possible. To achieve this objective, we will introduce the main concepts required for a good understanding of Grin as a Mimblewimble implementation. We will start with a brief description of some relevant properties of Elliptic Curve Cryptography (ECC) to lay the foundation on which Grin is based and then describe all the key elements of a Mimblewimble blockchain's transactions and blocks. Tiny Bits of Elliptic Curves We start with a brief primer on Elliptic Curve Cryptography, reviewing just the properties necessary to understand how Mimblewimble works and without delving too much into the intricacies of ECC. For readers who would want to dive deeper into those assumptions, there are other opportunities to learn more . An Elliptic Curve for the purpose of cryptography is simply a large set of points that we will call C . These points can be added, subtracted, or multiplied by integers (also called scalars). Given such a point H , an integer k and using the scalar multiplication operation we can compute k*H , which is also a point on curve C . Given another integer j we can also calculate (k+j)*H , which equals k*H + j*H . The addition and scalar multiplication operations on an elliptic curve maintain the commutative and associative properties of addition and multiplication: (k+j)*H = k*H + j*H In ECC, if we pick a very large number k as a private key, k*H is considered the corresponding public key. Even if one knows the value of the public key k*H , deducing k is close to impossible (or said differently, while multiplication is trivial, \"division\" by curve points is extremely difficult). The previous formula (k+j)*H = k*H + j*H , with k and j both private keys, demonstrates that a public key obtained from the addition of two private keys ( (k+j)*H ) is identical to the addition of the public keys for each of those two private keys ( k*H + j*H ). In the Bitcoin blockchain, Hierarchical Deterministic wallets heavily rely on this principle. Mimblewimble and the Grin implementation do as well. Transacting with Mimblewimble The structure of transactions demonstrates a crucial tenet of Mimblewimble: strong privacy and confidentiality guarantees. The validation of Mimblewimble transactions relies on two basic properties: Verification of zero sums. The sum of outputs minus inputs always equals zero, proving that the transaction did not create new funds, without revealing the actual amounts . Possession of private keys. Like with most other cryptocurrencies, ownership of transaction outputs is guaranteed by the possession of ECC private keys. However, the proof that an entity owns those private keys is not achieved by directly signing the transaction. The next sections on balance, ownership, change and proofs details how those two fundamental properties are achieved. Balance Building upon the properties of ECC we described above, one can obscure the values in a transaction. If v is the value of a transaction input or output and H a point on the elliptic curve C , we can simply embed v*H instead of v in a transaction. This works because using the ECC operations, we can still validate that the sum of the outputs of a transaction equals the sum of inputs: v1 + v2 = v3 => v1*H + v2*H = v3*H Verifying this property on every transaction allows the protocol to verify that a transaction doesn't create money out of thin air, without knowing what the actual values are. However, there are a finite number of usable values (transaction amounts) and one could try every single one of them to guess the value of the transaction. In addition, knowing v1 (from a previous transaction for example) and the resulting v1*H reveals all outputs with value v1 across the blockchain. For these reasons, we introduce a second point G on the same elliptic curve (practically G is just another generator point on the same curve group as H ) and a private key r used as a blinding factor . An input or output value in a transaction can then be expressed as: r*G + v*H Where: r is a private key used as a blinding factor, G is a point on the elliptic curve C and their product r*G is the public key for r (using G as generator point). v is the value of an input or output and H is another point on the elliptic curve C , together producing another public key v*H (using H as generator point). Neither v nor r can be deduced, leveraging the fundamental properties of Elliptic Curve Cryptography. r*G + v*H is called a Pedersen Commitment . As an example, let's assume we want to build a transaction with two inputs and one output. We have (ignoring fees): vi1 and vi2 as input values. vo3 as output value. Such that: vi1 + vi2 = vo3 Generating a private key as a blinding factor for each input value and replacing each value with their respective Pedersen Commitments in the previous equation, we obtain: (ri1*G + vi1*H) + (ri2*G + vi2*H) = (ro3*G + vo3*H) Which as a consequence requires that: ri1 + ri2 = ro3 This is the first pillar of Mimblewimble: the arithmetic required to validate a transaction can be done without knowing any of the values. As a final note, this idea is actually derived from Greg Maxwell's Confidential Transactions , which is itself derived from an Adam Back proposal for homomorphic values applied to Bitcoin. Ownership In the previous section we introduced a private key as a blinding factor to obscure the transaction's values. The second insight of Mimblewimble is that this private key can be leveraged to prove ownership of the value. Alice sends you 3 coins and to obscure that amount, you chose 28 as your blinding factor (note that in practice, the blinding factor being a private key, it's an extremely large number). Somewhere on the blockchain, the following output appears and should only be spendable by you: X = 28*G + 3*H X , the result of the addition, is visible by everyone. The value 3 is only known to you and Alice, and 28 is only known to you. To transfer those 3 coins again, the protocol requires 28 to be known somehow. To demonstrate how this works, let's say you want to transfer those 3 same coins to Carol. You need to build a simple transaction such that: Xi => Y Where Xi is an input that spends your X output and Y is Carol's output. There is no way to build such a transaction and balance it without knowing your private key of 28. Indeed, if Carol is to balance this transaction, she needs to know both the value sent and your private key so that: Y - Xi = (28*G + 3*H) - (28*G + 3*H) = 0*G + 0*H By checking that everything has been zeroed out, we can again make sure that no new money has been created. Wait! Stop! Now you know the private key in Carol's output (which, in this case, must be the same as yours to balance out) and so you could steal the money back from Carol! To solve this, Carol uses a private key of her choosing. She picks 113 say, and what ends up on the blockchain is: Y - Xi = (113*G + 3*H) - (28*G + 3*H) = 85*G + 0*H Now the transaction no longer sums to zero and we have an excess value (85), which is the result of the summation of all blinding factors. Because 85*G is a valid public key for the generator point G the input and output values must sum to zero and the transaction is thus valid, since x*G + y*H is a valid public key for generator point G if and only if y = 0 . So all the protocol needs to verify is that ( Y - Xi ) is a valid public key for generator point G and that the transacting parties collectively can produce its private key (85 in the above example). The simplest way to do so is to require a signature built with the excess value (85), which then ensures that: The transacting parties collectively can produce the private key (the excess value) The sum of the outputs minus the inputs are zero (because only a valid public key will check against the signature). This signature, attached to every transaction, together with some additional data (like mining fees), is called a transaction kernel and is checked by all validators. Some Finer Points This section elaborates on the building of transactions by discussing how change is introduced and the requirement for range proofs so all values are proven to be non-negative. Neither of these are absolutely required to understand Mimblewimble and Grin, so if you're in a hurry, feel free to jump straight to Putting It All Together . Change Let's say you only want to send 2 coins to Carol from the 3 you received from Alice. To do this you would send the remaining 1 coin back to yourself as change. You generate another private key (say 12) as a blinding factor to protect your change output. Carol uses her own private key as before. Change output: 12*G + 1*H Carol's output: 113*G + 2*H What ends up on the blockchain is something very similar to before. And the signature is again built with the excess value, 97 in this example. (12*G + 1*H) + (113*G + 2*H) - (28*G + 3*H) = 97*G + 0*H Range Proofs In all the above calculations, we rely on the transaction values to always be positive. The introduction of negative amounts would be extremely problematic as one could create new funds in every transaction. For example, one could create a transaction with an input of 2 and outputs of 5 and -3 and still obtain a well-balanced transaction. This can't be easily detected because even if x is negative, the corresponding point x*H on the curve looks like any other. To solve this problem, Mimblewimble leverages another cryptographic concept (also coming from Confidential Transactions) called range proofs: a proof that a number falls within a given range, without revealing the number. We won't elaborate on the range proof, but you just need to know that for any r*G + v*H we can build a proof that will show that v is greater than zero and does not overflow. It's also important to note that range proofs for both the blinding factor and the values are needed. The reason for this is that it prevents a censoring attack where a third party would be able to lock UTXOs without knowing their private keys by creating a transaction such as the following: Carol's UTXO: 113*G + 2*H Attacker's output: (113 + 99)*G + 2*H which can be signed by the attacker because Carol's blinding factor cancels out in the equation Y - Xi : Y - Xi = ((113 + 99)*G + 2*H) - (113*G + 2*H) = 99*G This output ( (113 + 99)*G + 2*H ) requires that both the numbers 113 and 99 are known in order to be spent; the attacker would thus have successfully locked Carol's UTXO. The requirement for a range proof for the blinding factor prevents this because the attacker doesn't know the number 113 and thus neither (113 + 99). A more detailed description of range proofs is further detailed in the range proof paper . Putting It All Together A Mimblewimble transaction includes the following: A set of inputs, that reference and spend a set of previous outputs. A set of new outputs that include: A value and a blinding factor (which is just a new private key) multiplied on a curve and summed to be r*G + v*H . A range proof that among other things shows that v is non-negative. An transaction fee in cleartext. A signature whose private key is computed by taking the excess value (the sum of all output values plus the fee, minus the input values). Blocks and Chain State We explained above how Mimblewimble transactions can provide strong anonymity guarantees while maintaining the properties required for a valid blockchain, i.e., a transaction does not create money and proof of ownership is established through private keys. The Mimblewimble block format builds on this by introducing one additional concept: cut-through . With this addition, a Mimblewimble chain gains: Extremely good scalability, as the great majority of transaction data can be eliminated over time, without compromising security. Further anonymity by mixing and removing transaction data. Transaction Aggregation Recall that a transaction consists of the following: a set of inputs that reference and spent a set of previous outputs a set of new outputs a transaction kernel consisting of: kernel excess (the public key of the excess value) transaction signature whose public key is the kernel excess A transaction is validated by determining that the kernel excess is a valid public key: (42*G + 1*H) + (99*G + 2*H) - (113*G + 3*H) = 28*G + 0*H The public key in this example is 28*G . We can say the following is true for any valid transaction (ignoring fees for simplicity): sum(outputs) - sum(inputs) = kernel_excess The same holds true for blocks themselves once we realize a block is simply a set of aggregated inputs, outputs and transaction kernels. We can sum the outputs, subtract the inputs from it and equating the resulting Pedersen commitment to the sum of the kernel excesses: sum(outputs) - sum(inputs) = sum(kernel_excess) Simplifying slightly, (again ignoring transaction fees) we can say that Mimblewimble blocks can be treated exactly as Mimblewimble transactions. Kernel Offsets There is a subtle problem with Mimblewimble blocks and transactions as described above. It is possible (and in some cases trivial) to reconstruct the constituent transactions in a block. This is clearly bad for privacy. This is the \"subset\" problem: given a set of inputs, outputs, and transaction kernels a subset of these will recombine to reconstruct a valid transaction. Consider the following two transactions: (in1, in2) -> (out1), (kern1) (in3) -> (out2), (kern2) We can aggregate them into the following block (or aggregate transaction): (in1, in2, in3) -> (out1, out2), (kern1, kern2) It is trivially easy to try all possible permutations to recover one of the transactions (where it successfully sums to zero): (in1, in2) -> (out1), (kern1) We also know that everything remaining can be used to reconstruct the other valid transaction: (in3) -> (out2), (kern2) Remember that the kernel excess r*G simply is the public key of the excess value r . To mitigate this we redefine the kernel excess from r*G to (r-kernel_offset)*G and distribute the kernel offset to be included with every transaction kernel. The kernel offset is thus a blinding factor that needs to be added to the excess value to ensure the commitments sum to zero: sum(outputs) - sum(inputs) = r*G = (r-kernel_offset)*G + kernel_offset*G or alternatively sum(outputs) - sum(inputs) = kernel_excess + kernel_offset*G For a commitment r*G + 0*H with the offset a , the transaction is signed with (r-a) and a is published so that r*G can be calculated in order to verify the validity of the transaction. During block construction all kernel offsets are summed to generate a single aggregate kernel offset to cover the whole block. The kernel offset for any individual transaction is then unrecoverable and the subset problem is solved. sum(outputs) - sum(inputs) = sum(kernel_excess) + kernel_offset*G Cut-through Blocks let miners assemble multiple transactions into a single set that's added to the chain. In the following block representations, containing 3 transactions, we only show inputs and outputs of transactions. Inputs reference outputs they spend. An output included in a previous block is marked with a lower-case x. I1(x1) --- O1 |- O2 I2(x2) --- O3 I3(O2) -| I4(O3) --- O4 |- O5 We notice the two following properties: Within this block, some outputs are directly spent by following inputs ( I3 spends O2 and I4 spends O3 ). The structure of each transaction does not actually matter. Since all transactions individually sum to zero, the sum of all transaction inputs and outputs must be zero. Similarly to a transaction, all that needs to be checked in a block is that ownership has been proven (which comes from the transaction kernels ) and that the whole block did not create any coins (other than what's allowed as the mining reward). Therefore, matching inputs and outputs can be eliminated, as their contribution to the overall sum cancels out. Which leads to the following, much more compact block: I1(x1) | O1 I2(x2) | O4 | O5 Note that all transaction structure has been eliminated and the order of inputs and outputs does not matter anymore. However, the sum of all inputs and outputs is still guaranteed to be zero. A block is simply built from: A block header. The list of inputs remaining after cut-through. The list of outputs remaining after cut-through. A single kernel offset to cover the full block. The transaction kernels containing, for each transaction: The public key r*G obtained from the summation of all inputs and outputs. The signatures generated using the excess value. The mining fee. When structured this way, a Mimblewimble block offers extremely good privacy guarantees: Intermediate (cut-through) transactions will be represented only by their transaction kernels. All outputs look the same: very large numbers that are impossible to meaningfully differentiate from one another. If someone wants to exclude a specific output, they'd have to exclude all. All transaction structure has been removed, making it impossible to tell which inputs and outputs match. And yet, it all still validates! Cut-through All The Way Going back to the previous example block, outputs x1 and x2 , spent by I1 and I2 , must have appeared previously in the blockchain. So after the addition of this block, those outputs as well as I1 and I2 can also be removed from the blockchain as they now are intermediate transactions. We conclude that the chain state (excluding headers) at any point in time can be summarized by just these pieces of information: The total amount of coins created by mining in the chain. The complete set of unspent outputs. The transactions kernels for each transaction. The first piece of information can be deduced just using the block height. Both the UTXOs and the transaction kernels are extremely compact. This has two important consequences: The blockchain a node needs to maintain is very small (on the order of a few gigabytes for a bitcoin-sized blockchain, and potentially optimizable to a few hundreds of megabytes). When a new node joins the network the amount of information that needs to be transferred is very small. In addition, the UTXO set cannot be tampered with. Adding or removing even one input or output would change the sum of the transactions to be something other than zero. Conclusion In this document we covered the basic principles that underlie a Mimblewimble blockchain. By using the addition properties of Elliptic Curve Cryptography, we're able to build transactions that are completely opaque but can still be properly validated. And by generalizing those properties to blocks, we can eliminate a large amount of blockchain data, allowing for great scaling and fast sync of new peers.","title":"Technical Introduction"},{"location":"technical/technical-introduction/#technical-introductionn-to-mimblewimble","text":"","title":"Technical Introductionn to Mimblewimble"},{"location":"technical/technical-introduction/#tongue-tying-for-everyone","text":"This document is targeted at readers with a good understanding of blockchains and basic cryptography. With that in mind, we attempt to explain the technical buildup of Mimblewimble and how it's applied in Grin. We hope this document is understandable to most technically-minded readers. Our objective is to encourage you to get interested in Grin and contribute in any way possible. To achieve this objective, we will introduce the main concepts required for a good understanding of Grin as a Mimblewimble implementation. We will start with a brief description of some relevant properties of Elliptic Curve Cryptography (ECC) to lay the foundation on which Grin is based and then describe all the key elements of a Mimblewimble blockchain's transactions and blocks.","title":"Tongue Tying for Everyone"},{"location":"technical/technical-introduction/#tiny-bits-of-elliptic-curves","text":"We start with a brief primer on Elliptic Curve Cryptography, reviewing just the properties necessary to understand how Mimblewimble works and without delving too much into the intricacies of ECC. For readers who would want to dive deeper into those assumptions, there are other opportunities to learn more . An Elliptic Curve for the purpose of cryptography is simply a large set of points that we will call C . These points can be added, subtracted, or multiplied by integers (also called scalars). Given such a point H , an integer k and using the scalar multiplication operation we can compute k*H , which is also a point on curve C . Given another integer j we can also calculate (k+j)*H , which equals k*H + j*H . The addition and scalar multiplication operations on an elliptic curve maintain the commutative and associative properties of addition and multiplication: (k+j)*H = k*H + j*H In ECC, if we pick a very large number k as a private key, k*H is considered the corresponding public key. Even if one knows the value of the public key k*H , deducing k is close to impossible (or said differently, while multiplication is trivial, \"division\" by curve points is extremely difficult). The previous formula (k+j)*H = k*H + j*H , with k and j both private keys, demonstrates that a public key obtained from the addition of two private keys ( (k+j)*H ) is identical to the addition of the public keys for each of those two private keys ( k*H + j*H ). In the Bitcoin blockchain, Hierarchical Deterministic wallets heavily rely on this principle. Mimblewimble and the Grin implementation do as well.","title":"Tiny Bits of Elliptic Curves"},{"location":"technical/technical-introduction/#transacting-with-mimblewimble","text":"The structure of transactions demonstrates a crucial tenet of Mimblewimble: strong privacy and confidentiality guarantees. The validation of Mimblewimble transactions relies on two basic properties: Verification of zero sums. The sum of outputs minus inputs always equals zero, proving that the transaction did not create new funds, without revealing the actual amounts . Possession of private keys. Like with most other cryptocurrencies, ownership of transaction outputs is guaranteed by the possession of ECC private keys. However, the proof that an entity owns those private keys is not achieved by directly signing the transaction. The next sections on balance, ownership, change and proofs details how those two fundamental properties are achieved.","title":"Transacting with Mimblewimble"},{"location":"technical/technical-introduction/#balance","text":"Building upon the properties of ECC we described above, one can obscure the values in a transaction. If v is the value of a transaction input or output and H a point on the elliptic curve C , we can simply embed v*H instead of v in a transaction. This works because using the ECC operations, we can still validate that the sum of the outputs of a transaction equals the sum of inputs: v1 + v2 = v3 => v1*H + v2*H = v3*H Verifying this property on every transaction allows the protocol to verify that a transaction doesn't create money out of thin air, without knowing what the actual values are. However, there are a finite number of usable values (transaction amounts) and one could try every single one of them to guess the value of the transaction. In addition, knowing v1 (from a previous transaction for example) and the resulting v1*H reveals all outputs with value v1 across the blockchain. For these reasons, we introduce a second point G on the same elliptic curve (practically G is just another generator point on the same curve group as H ) and a private key r used as a blinding factor . An input or output value in a transaction can then be expressed as: r*G + v*H Where: r is a private key used as a blinding factor, G is a point on the elliptic curve C and their product r*G is the public key for r (using G as generator point). v is the value of an input or output and H is another point on the elliptic curve C , together producing another public key v*H (using H as generator point). Neither v nor r can be deduced, leveraging the fundamental properties of Elliptic Curve Cryptography. r*G + v*H is called a Pedersen Commitment . As an example, let's assume we want to build a transaction with two inputs and one output. We have (ignoring fees): vi1 and vi2 as input values. vo3 as output value. Such that: vi1 + vi2 = vo3 Generating a private key as a blinding factor for each input value and replacing each value with their respective Pedersen Commitments in the previous equation, we obtain: (ri1*G + vi1*H) + (ri2*G + vi2*H) = (ro3*G + vo3*H) Which as a consequence requires that: ri1 + ri2 = ro3 This is the first pillar of Mimblewimble: the arithmetic required to validate a transaction can be done without knowing any of the values. As a final note, this idea is actually derived from Greg Maxwell's Confidential Transactions , which is itself derived from an Adam Back proposal for homomorphic values applied to Bitcoin.","title":"Balance"},{"location":"technical/technical-introduction/#ownership","text":"In the previous section we introduced a private key as a blinding factor to obscure the transaction's values. The second insight of Mimblewimble is that this private key can be leveraged to prove ownership of the value. Alice sends you 3 coins and to obscure that amount, you chose 28 as your blinding factor (note that in practice, the blinding factor being a private key, it's an extremely large number). Somewhere on the blockchain, the following output appears and should only be spendable by you: X = 28*G + 3*H X , the result of the addition, is visible by everyone. The value 3 is only known to you and Alice, and 28 is only known to you. To transfer those 3 coins again, the protocol requires 28 to be known somehow. To demonstrate how this works, let's say you want to transfer those 3 same coins to Carol. You need to build a simple transaction such that: Xi => Y Where Xi is an input that spends your X output and Y is Carol's output. There is no way to build such a transaction and balance it without knowing your private key of 28. Indeed, if Carol is to balance this transaction, she needs to know both the value sent and your private key so that: Y - Xi = (28*G + 3*H) - (28*G + 3*H) = 0*G + 0*H By checking that everything has been zeroed out, we can again make sure that no new money has been created. Wait! Stop! Now you know the private key in Carol's output (which, in this case, must be the same as yours to balance out) and so you could steal the money back from Carol! To solve this, Carol uses a private key of her choosing. She picks 113 say, and what ends up on the blockchain is: Y - Xi = (113*G + 3*H) - (28*G + 3*H) = 85*G + 0*H Now the transaction no longer sums to zero and we have an excess value (85), which is the result of the summation of all blinding factors. Because 85*G is a valid public key for the generator point G the input and output values must sum to zero and the transaction is thus valid, since x*G + y*H is a valid public key for generator point G if and only if y = 0 . So all the protocol needs to verify is that ( Y - Xi ) is a valid public key for generator point G and that the transacting parties collectively can produce its private key (85 in the above example). The simplest way to do so is to require a signature built with the excess value (85), which then ensures that: The transacting parties collectively can produce the private key (the excess value) The sum of the outputs minus the inputs are zero (because only a valid public key will check against the signature). This signature, attached to every transaction, together with some additional data (like mining fees), is called a transaction kernel and is checked by all validators.","title":"Ownership"},{"location":"technical/technical-introduction/#some-finer-points","text":"This section elaborates on the building of transactions by discussing how change is introduced and the requirement for range proofs so all values are proven to be non-negative. Neither of these are absolutely required to understand Mimblewimble and Grin, so if you're in a hurry, feel free to jump straight to Putting It All Together .","title":"Some Finer Points"},{"location":"technical/technical-introduction/#change","text":"Let's say you only want to send 2 coins to Carol from the 3 you received from Alice. To do this you would send the remaining 1 coin back to yourself as change. You generate another private key (say 12) as a blinding factor to protect your change output. Carol uses her own private key as before. Change output: 12*G + 1*H Carol's output: 113*G + 2*H What ends up on the blockchain is something very similar to before. And the signature is again built with the excess value, 97 in this example. (12*G + 1*H) + (113*G + 2*H) - (28*G + 3*H) = 97*G + 0*H","title":"Change"},{"location":"technical/technical-introduction/#range-proofs","text":"In all the above calculations, we rely on the transaction values to always be positive. The introduction of negative amounts would be extremely problematic as one could create new funds in every transaction. For example, one could create a transaction with an input of 2 and outputs of 5 and -3 and still obtain a well-balanced transaction. This can't be easily detected because even if x is negative, the corresponding point x*H on the curve looks like any other. To solve this problem, Mimblewimble leverages another cryptographic concept (also coming from Confidential Transactions) called range proofs: a proof that a number falls within a given range, without revealing the number. We won't elaborate on the range proof, but you just need to know that for any r*G + v*H we can build a proof that will show that v is greater than zero and does not overflow. It's also important to note that range proofs for both the blinding factor and the values are needed. The reason for this is that it prevents a censoring attack where a third party would be able to lock UTXOs without knowing their private keys by creating a transaction such as the following: Carol's UTXO: 113*G + 2*H Attacker's output: (113 + 99)*G + 2*H which can be signed by the attacker because Carol's blinding factor cancels out in the equation Y - Xi : Y - Xi = ((113 + 99)*G + 2*H) - (113*G + 2*H) = 99*G This output ( (113 + 99)*G + 2*H ) requires that both the numbers 113 and 99 are known in order to be spent; the attacker would thus have successfully locked Carol's UTXO. The requirement for a range proof for the blinding factor prevents this because the attacker doesn't know the number 113 and thus neither (113 + 99). A more detailed description of range proofs is further detailed in the range proof paper .","title":"Range Proofs"},{"location":"technical/technical-introduction/#putting-it-all-together","text":"A Mimblewimble transaction includes the following: A set of inputs, that reference and spend a set of previous outputs. A set of new outputs that include: A value and a blinding factor (which is just a new private key) multiplied on a curve and summed to be r*G + v*H . A range proof that among other things shows that v is non-negative. An transaction fee in cleartext. A signature whose private key is computed by taking the excess value (the sum of all output values plus the fee, minus the input values).","title":"Putting It All Together"},{"location":"technical/technical-introduction/#blocks-and-chain-state","text":"We explained above how Mimblewimble transactions can provide strong anonymity guarantees while maintaining the properties required for a valid blockchain, i.e., a transaction does not create money and proof of ownership is established through private keys. The Mimblewimble block format builds on this by introducing one additional concept: cut-through . With this addition, a Mimblewimble chain gains: Extremely good scalability, as the great majority of transaction data can be eliminated over time, without compromising security. Further anonymity by mixing and removing transaction data.","title":"Blocks and Chain State"},{"location":"technical/technical-introduction/#transaction-aggregation","text":"Recall that a transaction consists of the following: a set of inputs that reference and spent a set of previous outputs a set of new outputs a transaction kernel consisting of: kernel excess (the public key of the excess value) transaction signature whose public key is the kernel excess A transaction is validated by determining that the kernel excess is a valid public key: (42*G + 1*H) + (99*G + 2*H) - (113*G + 3*H) = 28*G + 0*H The public key in this example is 28*G . We can say the following is true for any valid transaction (ignoring fees for simplicity): sum(outputs) - sum(inputs) = kernel_excess The same holds true for blocks themselves once we realize a block is simply a set of aggregated inputs, outputs and transaction kernels. We can sum the outputs, subtract the inputs from it and equating the resulting Pedersen commitment to the sum of the kernel excesses: sum(outputs) - sum(inputs) = sum(kernel_excess) Simplifying slightly, (again ignoring transaction fees) we can say that Mimblewimble blocks can be treated exactly as Mimblewimble transactions.","title":"Transaction Aggregation"},{"location":"technical/technical-introduction/#kernel-offsets","text":"There is a subtle problem with Mimblewimble blocks and transactions as described above. It is possible (and in some cases trivial) to reconstruct the constituent transactions in a block. This is clearly bad for privacy. This is the \"subset\" problem: given a set of inputs, outputs, and transaction kernels a subset of these will recombine to reconstruct a valid transaction. Consider the following two transactions: (in1, in2) -> (out1), (kern1) (in3) -> (out2), (kern2) We can aggregate them into the following block (or aggregate transaction): (in1, in2, in3) -> (out1, out2), (kern1, kern2) It is trivially easy to try all possible permutations to recover one of the transactions (where it successfully sums to zero): (in1, in2) -> (out1), (kern1) We also know that everything remaining can be used to reconstruct the other valid transaction: (in3) -> (out2), (kern2) Remember that the kernel excess r*G simply is the public key of the excess value r . To mitigate this we redefine the kernel excess from r*G to (r-kernel_offset)*G and distribute the kernel offset to be included with every transaction kernel. The kernel offset is thus a blinding factor that needs to be added to the excess value to ensure the commitments sum to zero: sum(outputs) - sum(inputs) = r*G = (r-kernel_offset)*G + kernel_offset*G or alternatively sum(outputs) - sum(inputs) = kernel_excess + kernel_offset*G For a commitment r*G + 0*H with the offset a , the transaction is signed with (r-a) and a is published so that r*G can be calculated in order to verify the validity of the transaction. During block construction all kernel offsets are summed to generate a single aggregate kernel offset to cover the whole block. The kernel offset for any individual transaction is then unrecoverable and the subset problem is solved. sum(outputs) - sum(inputs) = sum(kernel_excess) + kernel_offset*G","title":"Kernel Offsets"},{"location":"technical/technical-introduction/#cut-through","text":"Blocks let miners assemble multiple transactions into a single set that's added to the chain. In the following block representations, containing 3 transactions, we only show inputs and outputs of transactions. Inputs reference outputs they spend. An output included in a previous block is marked with a lower-case x. I1(x1) --- O1 |- O2 I2(x2) --- O3 I3(O2) -| I4(O3) --- O4 |- O5 We notice the two following properties: Within this block, some outputs are directly spent by following inputs ( I3 spends O2 and I4 spends O3 ). The structure of each transaction does not actually matter. Since all transactions individually sum to zero, the sum of all transaction inputs and outputs must be zero. Similarly to a transaction, all that needs to be checked in a block is that ownership has been proven (which comes from the transaction kernels ) and that the whole block did not create any coins (other than what's allowed as the mining reward). Therefore, matching inputs and outputs can be eliminated, as their contribution to the overall sum cancels out. Which leads to the following, much more compact block: I1(x1) | O1 I2(x2) | O4 | O5 Note that all transaction structure has been eliminated and the order of inputs and outputs does not matter anymore. However, the sum of all inputs and outputs is still guaranteed to be zero. A block is simply built from: A block header. The list of inputs remaining after cut-through. The list of outputs remaining after cut-through. A single kernel offset to cover the full block. The transaction kernels containing, for each transaction: The public key r*G obtained from the summation of all inputs and outputs. The signatures generated using the excess value. The mining fee. When structured this way, a Mimblewimble block offers extremely good privacy guarantees: Intermediate (cut-through) transactions will be represented only by their transaction kernels. All outputs look the same: very large numbers that are impossible to meaningfully differentiate from one another. If someone wants to exclude a specific output, they'd have to exclude all. All transaction structure has been removed, making it impossible to tell which inputs and outputs match. And yet, it all still validates!","title":"Cut-through"},{"location":"technical/technical-introduction/#cut-through-all-the-way","text":"Going back to the previous example block, outputs x1 and x2 , spent by I1 and I2 , must have appeared previously in the blockchain. So after the addition of this block, those outputs as well as I1 and I2 can also be removed from the blockchain as they now are intermediate transactions. We conclude that the chain state (excluding headers) at any point in time can be summarized by just these pieces of information: The total amount of coins created by mining in the chain. The complete set of unspent outputs. The transactions kernels for each transaction. The first piece of information can be deduced just using the block height. Both the UTXOs and the transaction kernels are extremely compact. This has two important consequences: The blockchain a node needs to maintain is very small (on the order of a few gigabytes for a bitcoin-sized blockchain, and potentially optimizable to a few hundreds of megabytes). When a new node joins the network the amount of information that needs to be transferred is very small. In addition, the UTXO set cannot be tampered with. Adding or removing even one input or output would change the sum of the transactions to be something other than zero.","title":"Cut-through All The Way"},{"location":"technical/technical-introduction/#conclusion","text":"In this document we covered the basic principles that underlie a Mimblewimble blockchain. By using the addition properties of Elliptic Curve Cryptography, we're able to build transactions that are completely opaque but can still be properly validated. And by generalizing those properties to blocks, we can eliminate a large amount of blockchain data, allowing for great scaling and fast sync of new peers.","title":"Conclusion"},{"location":"technical/toc/","text":"Table of Contents Explaining Mimblewimble and Grin Technical Introduction to Mimblewimble Grin4Bitcoiners - Explaining Grin from a Bitcoiner's perspective Understand the Grin implementation Chain Sync - About how Grin's blockchain is synchronized Coinbase Maturity Blocks and Headers - How Grin tracks blocks and headers on the chain Contract Ideas - Ideas on how to implement contracts Dandelion - About transaction propagation and cut-through. Stemming and fluffing! Merkle Structures - Technical explanation of grin's favorite kind of merkle trees Merkle Proof Graph - Example Merkle proof with pruning applied Switch Commitments - Introduction to Switch Commiments Pruning - Technical explanation of pruning Stratum - Technical explanation of Grin Stratum RPC protocol Transaction UML - UML of an interactive transaction Rangeproof output format - Explanation of the byte output of a range proof in a Grin transaction","title":"Table of Contents"},{"location":"technical/toc/#table-of-contents","text":"","title":"Table of Contents"},{"location":"technical/toc/#explaining-mimblewimble-and-grin","text":"Technical Introduction to Mimblewimble Grin4Bitcoiners - Explaining Grin from a Bitcoiner's perspective","title":"Explaining Mimblewimble and Grin"},{"location":"technical/toc/#understand-the-grin-implementation","text":"Chain Sync - About how Grin's blockchain is synchronized Coinbase Maturity Blocks and Headers - How Grin tracks blocks and headers on the chain Contract Ideas - Ideas on how to implement contracts Dandelion - About transaction propagation and cut-through. Stemming and fluffing! Merkle Structures - Technical explanation of grin's favorite kind of merkle trees Merkle Proof Graph - Example Merkle proof with pruning applied Switch Commitments - Introduction to Switch Commiments Pruning - Technical explanation of pruning Stratum - Technical explanation of Grin Stratum RPC protocol Transaction UML - UML of an interactive transaction Rangeproof output format - Explanation of the byte output of a range proof in a Grin transaction","title":"Understand the Grin implementation"}]}